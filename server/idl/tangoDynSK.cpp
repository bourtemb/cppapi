// This file is generated by omniidl (C++ backend)- omniORB_4_0. Do not edit.

#include "tango.h"
#include <omniORB4/tcDescriptor.h>

OMNI_USING_NAMESPACE(omni)

static const char* _0RL_dyn_library_version = omniORB_4_0;

static CORBA::TypeCode_ptr _0RL_tc_Tango_mDevBoolean = CORBA::TypeCode::PR_alias_tc("IDL:Tango/DevBoolean:1.0", "DevBoolean", CORBA::TypeCode::PR_boolean_tc());


#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace Tango { 
  const CORBA::TypeCode_ptr _tc_DevBoolean = _0RL_tc_Tango_mDevBoolean;
} 
#else
const CORBA::TypeCode_ptr Tango::_tc_DevBoolean = _0RL_tc_Tango_mDevBoolean;
#endif

static CORBA::TypeCode_ptr _0RL_tc_Tango_mDevDouble = CORBA::TypeCode::PR_alias_tc("IDL:Tango/DevDouble:1.0", "DevDouble", CORBA::TypeCode::PR_double_tc());


#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace Tango { 
  const CORBA::TypeCode_ptr _tc_DevDouble = _0RL_tc_Tango_mDevDouble;
} 
#else
const CORBA::TypeCode_ptr Tango::_tc_DevDouble = _0RL_tc_Tango_mDevDouble;
#endif

static CORBA::TypeCode_ptr _0RL_tc_Tango_mDevFloat = CORBA::TypeCode::PR_alias_tc("IDL:Tango/DevFloat:1.0", "DevFloat", CORBA::TypeCode::PR_float_tc());


#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace Tango { 
  const CORBA::TypeCode_ptr _tc_DevFloat = _0RL_tc_Tango_mDevFloat;
} 
#else
const CORBA::TypeCode_ptr Tango::_tc_DevFloat = _0RL_tc_Tango_mDevFloat;
#endif

static CORBA::TypeCode_ptr _0RL_tc_Tango_mDevLong = CORBA::TypeCode::PR_alias_tc("IDL:Tango/DevLong:1.0", "DevLong", CORBA::TypeCode::PR_long_tc());


#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace Tango { 
  const CORBA::TypeCode_ptr _tc_DevLong = _0RL_tc_Tango_mDevLong;
} 
#else
const CORBA::TypeCode_ptr Tango::_tc_DevLong = _0RL_tc_Tango_mDevLong;
#endif

static CORBA::TypeCode_ptr _0RL_tc_Tango_mDevShort = CORBA::TypeCode::PR_alias_tc("IDL:Tango/DevShort:1.0", "DevShort", CORBA::TypeCode::PR_short_tc());


#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace Tango { 
  const CORBA::TypeCode_ptr _tc_DevShort = _0RL_tc_Tango_mDevShort;
} 
#else
const CORBA::TypeCode_ptr Tango::_tc_DevShort = _0RL_tc_Tango_mDevShort;
#endif

static CORBA::TypeCode_ptr _0RL_tc_Tango_mDevString = CORBA::TypeCode::PR_alias_tc("IDL:Tango/DevString:1.0", "DevString", CORBA::TypeCode::PR_string_tc(0));


#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace Tango { 
  const CORBA::TypeCode_ptr _tc_DevString = _0RL_tc_Tango_mDevString;
} 
#else
const CORBA::TypeCode_ptr Tango::_tc_DevString = _0RL_tc_Tango_mDevString;
#endif

static CORBA::TypeCode_ptr _0RL_tc_Tango_mDevULong = CORBA::TypeCode::PR_alias_tc("IDL:Tango/DevULong:1.0", "DevULong", CORBA::TypeCode::PR_ulong_tc());


#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace Tango { 
  const CORBA::TypeCode_ptr _tc_DevULong = _0RL_tc_Tango_mDevULong;
} 
#else
const CORBA::TypeCode_ptr Tango::_tc_DevULong = _0RL_tc_Tango_mDevULong;
#endif

static CORBA::TypeCode_ptr _0RL_tc_Tango_mDevUShort = CORBA::TypeCode::PR_alias_tc("IDL:Tango/DevUShort:1.0", "DevUShort", CORBA::TypeCode::PR_ushort_tc());


#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace Tango { 
  const CORBA::TypeCode_ptr _tc_DevUShort = _0RL_tc_Tango_mDevUShort;
} 
#else
const CORBA::TypeCode_ptr Tango::_tc_DevUShort = _0RL_tc_Tango_mDevUShort;
#endif

static CORBA::TypeCode_ptr _0RL_tc_Tango_mDevVarFloatArray = CORBA::TypeCode::PR_alias_tc("IDL:Tango/DevVarFloatArray:1.0", "DevVarFloatArray", CORBA::TypeCode::PR_sequence_tc(0, CORBA::TypeCode::PR_float_tc()));


#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace Tango { 
  const CORBA::TypeCode_ptr _tc_DevVarFloatArray = _0RL_tc_Tango_mDevVarFloatArray;
} 
#else
const CORBA::TypeCode_ptr Tango::_tc_DevVarFloatArray = _0RL_tc_Tango_mDevVarFloatArray;
#endif

static CORBA::TypeCode_ptr _0RL_tc_Tango_mDevVarDoubleArray = CORBA::TypeCode::PR_alias_tc("IDL:Tango/DevVarDoubleArray:1.0", "DevVarDoubleArray", CORBA::TypeCode::PR_sequence_tc(0, CORBA::TypeCode::PR_double_tc()));


#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace Tango { 
  const CORBA::TypeCode_ptr _tc_DevVarDoubleArray = _0RL_tc_Tango_mDevVarDoubleArray;
} 
#else
const CORBA::TypeCode_ptr Tango::_tc_DevVarDoubleArray = _0RL_tc_Tango_mDevVarDoubleArray;
#endif

static CORBA::TypeCode_ptr _0RL_tc_Tango_mDevVarShortArray = CORBA::TypeCode::PR_alias_tc("IDL:Tango/DevVarShortArray:1.0", "DevVarShortArray", CORBA::TypeCode::PR_sequence_tc(0, CORBA::TypeCode::PR_short_tc()));


#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace Tango { 
  const CORBA::TypeCode_ptr _tc_DevVarShortArray = _0RL_tc_Tango_mDevVarShortArray;
} 
#else
const CORBA::TypeCode_ptr Tango::_tc_DevVarShortArray = _0RL_tc_Tango_mDevVarShortArray;
#endif

static CORBA::TypeCode_ptr _0RL_tc_Tango_mDevVarLongArray = CORBA::TypeCode::PR_alias_tc("IDL:Tango/DevVarLongArray:1.0", "DevVarLongArray", CORBA::TypeCode::PR_sequence_tc(0, CORBA::TypeCode::PR_long_tc()));


#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace Tango { 
  const CORBA::TypeCode_ptr _tc_DevVarLongArray = _0RL_tc_Tango_mDevVarLongArray;
} 
#else
const CORBA::TypeCode_ptr Tango::_tc_DevVarLongArray = _0RL_tc_Tango_mDevVarLongArray;
#endif

static CORBA::TypeCode_ptr _0RL_tc_Tango_mDevVarCharArray = CORBA::TypeCode::PR_alias_tc("IDL:Tango/DevVarCharArray:1.0", "DevVarCharArray", CORBA::TypeCode::PR_sequence_tc(0, CORBA::TypeCode::PR_octet_tc()));


#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace Tango { 
  const CORBA::TypeCode_ptr _tc_DevVarCharArray = _0RL_tc_Tango_mDevVarCharArray;
} 
#else
const CORBA::TypeCode_ptr Tango::_tc_DevVarCharArray = _0RL_tc_Tango_mDevVarCharArray;
#endif

static CORBA::TypeCode_ptr _0RL_tc_Tango_mDevVarStringArray = CORBA::TypeCode::PR_alias_tc("IDL:Tango/DevVarStringArray:1.0", "DevVarStringArray", CORBA::TypeCode::PR_sequence_tc(0, CORBA::TypeCode::PR_string_tc(0)));


#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace Tango { 
  const CORBA::TypeCode_ptr _tc_DevVarStringArray = _0RL_tc_Tango_mDevVarStringArray;
} 
#else
const CORBA::TypeCode_ptr Tango::_tc_DevVarStringArray = _0RL_tc_Tango_mDevVarStringArray;
#endif

static CORBA::TypeCode_ptr _0RL_tc_Tango_mDevVarUShortArray = CORBA::TypeCode::PR_alias_tc("IDL:Tango/DevVarUShortArray:1.0", "DevVarUShortArray", CORBA::TypeCode::PR_sequence_tc(0, CORBA::TypeCode::PR_ushort_tc()));


#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace Tango { 
  const CORBA::TypeCode_ptr _tc_DevVarUShortArray = _0RL_tc_Tango_mDevVarUShortArray;
} 
#else
const CORBA::TypeCode_ptr Tango::_tc_DevVarUShortArray = _0RL_tc_Tango_mDevVarUShortArray;
#endif

static CORBA::TypeCode_ptr _0RL_tc_Tango_mDevVarULongArray = CORBA::TypeCode::PR_alias_tc("IDL:Tango/DevVarULongArray:1.0", "DevVarULongArray", CORBA::TypeCode::PR_sequence_tc(0, CORBA::TypeCode::PR_ulong_tc()));


#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace Tango { 
  const CORBA::TypeCode_ptr _tc_DevVarULongArray = _0RL_tc_Tango_mDevVarULongArray;
} 
#else
const CORBA::TypeCode_ptr Tango::_tc_DevVarULongArray = _0RL_tc_Tango_mDevVarULongArray;
#endif

static CORBA::PR_structMember _0RL_structmember_Tango_mDevVarLongStringArray[] = {
  {"lvalue", _0RL_tc_Tango_mDevVarLongArray},
  {"svalue", _0RL_tc_Tango_mDevVarStringArray}
};

static CORBA::TypeCode_ptr _0RL_tc_Tango_mDevVarLongStringArray = CORBA::TypeCode::PR_struct_tc("IDL:Tango/DevVarLongStringArray:1.0", "DevVarLongStringArray", _0RL_structmember_Tango_mDevVarLongStringArray, 2);
#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace Tango { 
  const CORBA::TypeCode_ptr _tc_DevVarLongStringArray = _0RL_tc_Tango_mDevVarLongStringArray;
} 
#else
const CORBA::TypeCode_ptr Tango::_tc_DevVarLongStringArray = _0RL_tc_Tango_mDevVarLongStringArray;
#endif


static CORBA::PR_structMember _0RL_structmember_Tango_mDevVarDoubleStringArray[] = {
  {"dvalue", _0RL_tc_Tango_mDevVarDoubleArray},
  {"svalue", _0RL_tc_Tango_mDevVarStringArray}
};

static CORBA::TypeCode_ptr _0RL_tc_Tango_mDevVarDoubleStringArray = CORBA::TypeCode::PR_struct_tc("IDL:Tango/DevVarDoubleStringArray:1.0", "DevVarDoubleStringArray", _0RL_structmember_Tango_mDevVarDoubleStringArray, 2);
#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace Tango { 
  const CORBA::TypeCode_ptr _tc_DevVarDoubleStringArray = _0RL_tc_Tango_mDevVarDoubleStringArray;
} 
#else
const CORBA::TypeCode_ptr Tango::_tc_DevVarDoubleStringArray = _0RL_tc_Tango_mDevVarDoubleStringArray;
#endif


static const char* _0RL_enumMember_Tango_mAttrQuality[] = { "ATTR_VALID", "ATTR_INVALID", "ATTR_ALARM" };
static CORBA::TypeCode_ptr _0RL_tc_Tango_mAttrQuality = CORBA::TypeCode::PR_enum_tc("IDL:Tango/AttrQuality:1.0", "AttrQuality", _0RL_enumMember_Tango_mAttrQuality, 3);
#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace Tango { 
  const CORBA::TypeCode_ptr _tc_AttrQuality = _0RL_tc_Tango_mAttrQuality;
} 
#else
const CORBA::TypeCode_ptr Tango::_tc_AttrQuality = _0RL_tc_Tango_mAttrQuality;
#endif

static const char* _0RL_enumMember_Tango_mAttrWriteType[] = { "READ", "READ_WITH_WRITE", "WRITE", "READ_WRITE" };
static CORBA::TypeCode_ptr _0RL_tc_Tango_mAttrWriteType = CORBA::TypeCode::PR_enum_tc("IDL:Tango/AttrWriteType:1.0", "AttrWriteType", _0RL_enumMember_Tango_mAttrWriteType, 4);
#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace Tango { 
  const CORBA::TypeCode_ptr _tc_AttrWriteType = _0RL_tc_Tango_mAttrWriteType;
} 
#else
const CORBA::TypeCode_ptr Tango::_tc_AttrWriteType = _0RL_tc_Tango_mAttrWriteType;
#endif

static const char* _0RL_enumMember_Tango_mAttrDataFormat[] = { "SCALAR", "SPECTRUM", "IMAGE" };
static CORBA::TypeCode_ptr _0RL_tc_Tango_mAttrDataFormat = CORBA::TypeCode::PR_enum_tc("IDL:Tango/AttrDataFormat:1.0", "AttrDataFormat", _0RL_enumMember_Tango_mAttrDataFormat, 3);
#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace Tango { 
  const CORBA::TypeCode_ptr _tc_AttrDataFormat = _0RL_tc_Tango_mAttrDataFormat;
} 
#else
const CORBA::TypeCode_ptr Tango::_tc_AttrDataFormat = _0RL_tc_Tango_mAttrDataFormat;
#endif

static const char* _0RL_enumMember_Tango_mDevSource[] = { "DEV", "CACHE", "CACHE_DEV" };
static CORBA::TypeCode_ptr _0RL_tc_Tango_mDevSource = CORBA::TypeCode::PR_enum_tc("IDL:Tango/DevSource:1.0", "DevSource", _0RL_enumMember_Tango_mDevSource, 3);
#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace Tango { 
  const CORBA::TypeCode_ptr _tc_DevSource = _0RL_tc_Tango_mDevSource;
} 
#else
const CORBA::TypeCode_ptr Tango::_tc_DevSource = _0RL_tc_Tango_mDevSource;
#endif

static const char* _0RL_enumMember_Tango_mErrSeverity[] = { "WARN", "ERR", "PANIC" };
static CORBA::TypeCode_ptr _0RL_tc_Tango_mErrSeverity = CORBA::TypeCode::PR_enum_tc("IDL:Tango/ErrSeverity:1.0", "ErrSeverity", _0RL_enumMember_Tango_mErrSeverity, 3);
#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace Tango { 
  const CORBA::TypeCode_ptr _tc_ErrSeverity = _0RL_tc_Tango_mErrSeverity;
} 
#else
const CORBA::TypeCode_ptr Tango::_tc_ErrSeverity = _0RL_tc_Tango_mErrSeverity;
#endif

static const char* _0RL_enumMember_Tango_mDevState[] = { "ON", "OFF", "CLOSE", "OPEN", "INSERT", "EXTRACT", "MOVING", "STANDBY", "FAULT", "INIT", "RUNNING", "ALARM", "DISABLE", "UNKNOWN" };
static CORBA::TypeCode_ptr _0RL_tc_Tango_mDevState = CORBA::TypeCode::PR_enum_tc("IDL:Tango/DevState:1.0", "DevState", _0RL_enumMember_Tango_mDevState, 14);
#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace Tango { 
  const CORBA::TypeCode_ptr _tc_DevState = _0RL_tc_Tango_mDevState;
} 
#else
const CORBA::TypeCode_ptr Tango::_tc_DevState = _0RL_tc_Tango_mDevState;
#endif

static const char* _0RL_enumMember_Tango_mDispLevel[] = { "OPERATOR", "EXPERT" };
static CORBA::TypeCode_ptr _0RL_tc_Tango_mDispLevel = CORBA::TypeCode::PR_enum_tc("IDL:Tango/DispLevel:1.0", "DispLevel", _0RL_enumMember_Tango_mDispLevel, 2);
#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace Tango { 
  const CORBA::TypeCode_ptr _tc_DispLevel = _0RL_tc_Tango_mDispLevel;
} 
#else
const CORBA::TypeCode_ptr Tango::_tc_DispLevel = _0RL_tc_Tango_mDispLevel;
#endif

static CORBA::PR_structMember _0RL_structmember_Tango_mTimeVal[] = {
  {"tv_sec", CORBA::TypeCode::PR_long_tc()},
  {"tv_usec", CORBA::TypeCode::PR_long_tc()},
  {"tv_nsec", CORBA::TypeCode::PR_long_tc()}
};

static CORBA::TypeCode_ptr _0RL_tc_Tango_mTimeVal = CORBA::TypeCode::PR_struct_tc("IDL:Tango/TimeVal:1.0", "TimeVal", _0RL_structmember_Tango_mTimeVal, 3);
#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace Tango { 
  const CORBA::TypeCode_ptr _tc_TimeVal = _0RL_tc_Tango_mTimeVal;
} 
#else
const CORBA::TypeCode_ptr Tango::_tc_TimeVal = _0RL_tc_Tango_mTimeVal;
#endif


static CORBA::PR_structMember _0RL_structmember_Tango_mDevCmdInfo[] = {
  {"cmd_name", CORBA::TypeCode::PR_string_tc(0)},
  {"cmd_tag", CORBA::TypeCode::PR_long_tc()},
  {"in_type", CORBA::TypeCode::PR_long_tc()},
  {"out_type", CORBA::TypeCode::PR_long_tc()},
  {"in_type_desc", CORBA::TypeCode::PR_string_tc(0)},
  {"out_type_desc", CORBA::TypeCode::PR_string_tc(0)}
};

static CORBA::TypeCode_ptr _0RL_tc_Tango_mDevCmdInfo = CORBA::TypeCode::PR_struct_tc("IDL:Tango/DevCmdInfo:1.0", "DevCmdInfo", _0RL_structmember_Tango_mDevCmdInfo, 6);
#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace Tango { 
  const CORBA::TypeCode_ptr _tc_DevCmdInfo = _0RL_tc_Tango_mDevCmdInfo;
} 
#else
const CORBA::TypeCode_ptr Tango::_tc_DevCmdInfo = _0RL_tc_Tango_mDevCmdInfo;
#endif


static CORBA::PR_structMember _0RL_structmember_Tango_mDevCmdInfo__2[] = {
  {"cmd_name", CORBA::TypeCode::PR_string_tc(0)},
  {"level", _0RL_tc_Tango_mDispLevel},
  {"cmd_tag", CORBA::TypeCode::PR_long_tc()},
  {"in_type", CORBA::TypeCode::PR_long_tc()},
  {"out_type", CORBA::TypeCode::PR_long_tc()},
  {"in_type_desc", CORBA::TypeCode::PR_string_tc(0)},
  {"out_type_desc", CORBA::TypeCode::PR_string_tc(0)}
};

static CORBA::TypeCode_ptr _0RL_tc_Tango_mDevCmdInfo__2 = CORBA::TypeCode::PR_struct_tc("IDL:Tango/DevCmdInfo_2:1.0", "DevCmdInfo_2", _0RL_structmember_Tango_mDevCmdInfo__2, 7);
#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace Tango { 
  const CORBA::TypeCode_ptr _tc_DevCmdInfo_2 = _0RL_tc_Tango_mDevCmdInfo__2;
} 
#else
const CORBA::TypeCode_ptr Tango::_tc_DevCmdInfo_2 = _0RL_tc_Tango_mDevCmdInfo__2;
#endif






static CORBA::TypeCode_ptr _0RL_tc_Tango_mDevCmdInfoList = CORBA::TypeCode::PR_alias_tc("IDL:Tango/DevCmdInfoList:1.0", "DevCmdInfoList", CORBA::TypeCode::PR_sequence_tc(0, _0RL_tc_Tango_mDevCmdInfo));


#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace Tango { 
  const CORBA::TypeCode_ptr _tc_DevCmdInfoList = _0RL_tc_Tango_mDevCmdInfoList;
} 
#else
const CORBA::TypeCode_ptr Tango::_tc_DevCmdInfoList = _0RL_tc_Tango_mDevCmdInfoList;
#endif





static CORBA::TypeCode_ptr _0RL_tc_Tango_mDevCmdInfoList__2 = CORBA::TypeCode::PR_alias_tc("IDL:Tango/DevCmdInfoList_2:1.0", "DevCmdInfoList_2", CORBA::TypeCode::PR_sequence_tc(0, _0RL_tc_Tango_mDevCmdInfo__2));


#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace Tango { 
  const CORBA::TypeCode_ptr _tc_DevCmdInfoList_2 = _0RL_tc_Tango_mDevCmdInfoList__2;
} 
#else
const CORBA::TypeCode_ptr Tango::_tc_DevCmdInfoList_2 = _0RL_tc_Tango_mDevCmdInfoList__2;
#endif

static CORBA::PR_structMember _0RL_structmember_Tango_mDevError[] = {
  {"reason", CORBA::TypeCode::PR_string_tc(0)},
  {"severity", _0RL_tc_Tango_mErrSeverity},
  {"desc", CORBA::TypeCode::PR_string_tc(0)},
  {"origin", CORBA::TypeCode::PR_string_tc(0)}
};

static CORBA::TypeCode_ptr _0RL_tc_Tango_mDevError = CORBA::TypeCode::PR_struct_tc("IDL:Tango/DevError:1.0", "DevError", _0RL_structmember_Tango_mDevError, 4);
#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace Tango { 
  const CORBA::TypeCode_ptr _tc_DevError = _0RL_tc_Tango_mDevError;
} 
#else
const CORBA::TypeCode_ptr Tango::_tc_DevError = _0RL_tc_Tango_mDevError;
#endif






static CORBA::TypeCode_ptr _0RL_tc_Tango_mDevErrorList = CORBA::TypeCode::PR_alias_tc("IDL:Tango/DevErrorList:1.0", "DevErrorList", CORBA::TypeCode::PR_sequence_tc(0, _0RL_tc_Tango_mDevError));


#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace Tango { 
  const CORBA::TypeCode_ptr _tc_DevErrorList = _0RL_tc_Tango_mDevErrorList;
} 
#else
const CORBA::TypeCode_ptr Tango::_tc_DevErrorList = _0RL_tc_Tango_mDevErrorList;
#endif


static CORBA::PR_structMember _0RL_structmember_Tango_mDevFailed[] = {
  {"errors", _0RL_tc_Tango_mDevErrorList}
};

static CORBA::TypeCode_ptr _0RL_tc_Tango_mDevFailed = CORBA::TypeCode::PR_exception_tc("IDL:Tango/DevFailed:1.0", "DevFailed", _0RL_structmember_Tango_mDevFailed, 1);

#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace Tango { 
  const CORBA::TypeCode_ptr _tc_DevFailed = _0RL_tc_Tango_mDevFailed;
} 
#else
const CORBA::TypeCode_ptr Tango::_tc_DevFailed = _0RL_tc_Tango_mDevFailed;
#endif


static CORBA::PR_structMember _0RL_structmember_Tango_mAttributeConfig[] = {
  {"name", CORBA::TypeCode::PR_string_tc(0)},
  {"writable", _0RL_tc_Tango_mAttrWriteType},
  {"data_format", _0RL_tc_Tango_mAttrDataFormat},
  {"data_type", CORBA::TypeCode::PR_long_tc()},
  {"max_dim_x", CORBA::TypeCode::PR_long_tc()},
  {"max_dim_y", CORBA::TypeCode::PR_long_tc()},
  {"description", CORBA::TypeCode::PR_string_tc(0)},
  {"label", CORBA::TypeCode::PR_string_tc(0)},
  {"unit", CORBA::TypeCode::PR_string_tc(0)},
  {"standard_unit", CORBA::TypeCode::PR_string_tc(0)},
  {"display_unit", CORBA::TypeCode::PR_string_tc(0)},
  {"format", CORBA::TypeCode::PR_string_tc(0)},
  {"min_value", CORBA::TypeCode::PR_string_tc(0)},
  {"max_value", CORBA::TypeCode::PR_string_tc(0)},
  {"min_alarm", CORBA::TypeCode::PR_string_tc(0)},
  {"max_alarm", CORBA::TypeCode::PR_string_tc(0)},
  {"writable_attr_name", CORBA::TypeCode::PR_string_tc(0)},
  {"extensions", _0RL_tc_Tango_mDevVarStringArray}
};

static CORBA::TypeCode_ptr _0RL_tc_Tango_mAttributeConfig = CORBA::TypeCode::PR_struct_tc("IDL:Tango/AttributeConfig:1.0", "AttributeConfig", _0RL_structmember_Tango_mAttributeConfig, 18);
#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace Tango { 
  const CORBA::TypeCode_ptr _tc_AttributeConfig = _0RL_tc_Tango_mAttributeConfig;
} 
#else
const CORBA::TypeCode_ptr Tango::_tc_AttributeConfig = _0RL_tc_Tango_mAttributeConfig;
#endif


static CORBA::PR_structMember _0RL_structmember_Tango_mAttributeConfig__2[] = {
  {"name", CORBA::TypeCode::PR_string_tc(0)},
  {"writable", _0RL_tc_Tango_mAttrWriteType},
  {"data_format", _0RL_tc_Tango_mAttrDataFormat},
  {"data_type", CORBA::TypeCode::PR_long_tc()},
  {"max_dim_x", CORBA::TypeCode::PR_long_tc()},
  {"max_dim_y", CORBA::TypeCode::PR_long_tc()},
  {"description", CORBA::TypeCode::PR_string_tc(0)},
  {"label", CORBA::TypeCode::PR_string_tc(0)},
  {"unit", CORBA::TypeCode::PR_string_tc(0)},
  {"standard_unit", CORBA::TypeCode::PR_string_tc(0)},
  {"display_unit", CORBA::TypeCode::PR_string_tc(0)},
  {"format", CORBA::TypeCode::PR_string_tc(0)},
  {"min_value", CORBA::TypeCode::PR_string_tc(0)},
  {"max_value", CORBA::TypeCode::PR_string_tc(0)},
  {"min_alarm", CORBA::TypeCode::PR_string_tc(0)},
  {"max_alarm", CORBA::TypeCode::PR_string_tc(0)},
  {"writable_attr_name", CORBA::TypeCode::PR_string_tc(0)},
  {"level", _0RL_tc_Tango_mDispLevel},
  {"extensions", _0RL_tc_Tango_mDevVarStringArray}
};

static CORBA::TypeCode_ptr _0RL_tc_Tango_mAttributeConfig__2 = CORBA::TypeCode::PR_struct_tc("IDL:Tango/AttributeConfig_2:1.0", "AttributeConfig_2", _0RL_structmember_Tango_mAttributeConfig__2, 19);
#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace Tango { 
  const CORBA::TypeCode_ptr _tc_AttributeConfig_2 = _0RL_tc_Tango_mAttributeConfig__2;
} 
#else
const CORBA::TypeCode_ptr Tango::_tc_AttributeConfig_2 = _0RL_tc_Tango_mAttributeConfig__2;
#endif



static CORBA::PR_structMember _0RL_structmember_Tango_mAttributeValue[] = {
  {"value", CORBA::TypeCode::PR_any_tc()},
  {"quality", _0RL_tc_Tango_mAttrQuality},
  {"time", _0RL_tc_Tango_mTimeVal},
  {"name", CORBA::TypeCode::PR_string_tc(0)},
  {"dim_x", CORBA::TypeCode::PR_long_tc()},
  {"dim_y", CORBA::TypeCode::PR_long_tc()}
};

static CORBA::TypeCode_ptr _0RL_tc_Tango_mAttributeValue = CORBA::TypeCode::PR_struct_tc("IDL:Tango/AttributeValue:1.0", "AttributeValue", _0RL_structmember_Tango_mAttributeValue, 6);

#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace Tango { 
  const CORBA::TypeCode_ptr _tc_AttributeValue = _0RL_tc_Tango_mAttributeValue;
} 
#else
const CORBA::TypeCode_ptr Tango::_tc_AttributeValue = _0RL_tc_Tango_mAttributeValue;
#endif






static CORBA::TypeCode_ptr _0RL_tc_Tango_mAttributeConfigList = CORBA::TypeCode::PR_alias_tc("IDL:Tango/AttributeConfigList:1.0", "AttributeConfigList", CORBA::TypeCode::PR_sequence_tc(0, _0RL_tc_Tango_mAttributeConfig));


#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace Tango { 
  const CORBA::TypeCode_ptr _tc_AttributeConfigList = _0RL_tc_Tango_mAttributeConfigList;
} 
#else
const CORBA::TypeCode_ptr Tango::_tc_AttributeConfigList = _0RL_tc_Tango_mAttributeConfigList;
#endif





static CORBA::TypeCode_ptr _0RL_tc_Tango_mAttributeConfigList__2 = CORBA::TypeCode::PR_alias_tc("IDL:Tango/AttributeConfigList_2:1.0", "AttributeConfigList_2", CORBA::TypeCode::PR_sequence_tc(0, _0RL_tc_Tango_mAttributeConfig__2));


#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace Tango { 
  const CORBA::TypeCode_ptr _tc_AttributeConfigList_2 = _0RL_tc_Tango_mAttributeConfigList__2;
} 
#else
const CORBA::TypeCode_ptr Tango::_tc_AttributeConfigList_2 = _0RL_tc_Tango_mAttributeConfigList__2;
#endif









static CORBA::TypeCode_ptr _0RL_tc_Tango_mAttributeValueList = CORBA::TypeCode::PR_alias_tc("IDL:Tango/AttributeValueList:1.0", "AttributeValueList", CORBA::TypeCode::PR_sequence_tc(0, _0RL_tc_Tango_mAttributeValue));


#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace Tango { 
  const CORBA::TypeCode_ptr _tc_AttributeValueList = _0RL_tc_Tango_mAttributeValueList;
} 
#else
const CORBA::TypeCode_ptr Tango::_tc_AttributeValueList = _0RL_tc_Tango_mAttributeValueList;
#endif

static CORBA::PR_structMember _0RL_structmember_Tango_mDevInfo[] = {
  {"dev_class", CORBA::TypeCode::PR_string_tc(0)},
  {"server_id", CORBA::TypeCode::PR_string_tc(0)},
  {"server_host", CORBA::TypeCode::PR_string_tc(0)},
  {"server_version", CORBA::TypeCode::PR_long_tc()},
  {"doc_url", CORBA::TypeCode::PR_string_tc(0)}
};

static CORBA::TypeCode_ptr _0RL_tc_Tango_mDevInfo = CORBA::TypeCode::PR_struct_tc("IDL:Tango/DevInfo:1.0", "DevInfo", _0RL_structmember_Tango_mDevInfo, 5);
#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace Tango { 
  const CORBA::TypeCode_ptr _tc_DevInfo = _0RL_tc_Tango_mDevInfo;
} 
#else
const CORBA::TypeCode_ptr Tango::_tc_DevInfo = _0RL_tc_Tango_mDevInfo;
#endif




static CORBA::PR_structMember _0RL_structmember_Tango_mDevCmdHistory[] = {
  {"time", _0RL_tc_Tango_mTimeVal},
  {"cmd_failed", CORBA::TypeCode::PR_boolean_tc()},
  {"value", CORBA::TypeCode::PR_any_tc()},
  {"errors", _0RL_tc_Tango_mDevErrorList}
};

static CORBA::TypeCode_ptr _0RL_tc_Tango_mDevCmdHistory = CORBA::TypeCode::PR_struct_tc("IDL:Tango/DevCmdHistory:1.0", "DevCmdHistory", _0RL_structmember_Tango_mDevCmdHistory, 4);


#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace Tango { 
  const CORBA::TypeCode_ptr _tc_DevCmdHistory = _0RL_tc_Tango_mDevCmdHistory;
} 
#else
const CORBA::TypeCode_ptr Tango::_tc_DevCmdHistory = _0RL_tc_Tango_mDevCmdHistory;
#endif














static CORBA::TypeCode_ptr _0RL_tc_Tango_mDevCmdHistoryList = CORBA::TypeCode::PR_alias_tc("IDL:Tango/DevCmdHistoryList:1.0", "DevCmdHistoryList", CORBA::TypeCode::PR_sequence_tc(0, _0RL_tc_Tango_mDevCmdHistory));


#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace Tango { 
  const CORBA::TypeCode_ptr _tc_DevCmdHistoryList = _0RL_tc_Tango_mDevCmdHistoryList;
} 
#else
const CORBA::TypeCode_ptr Tango::_tc_DevCmdHistoryList = _0RL_tc_Tango_mDevCmdHistoryList;
#endif




static CORBA::PR_structMember _0RL_structmember_Tango_mDevAttrHistory[] = {
  {"attr_failed", CORBA::TypeCode::PR_boolean_tc()},
  {"value", _0RL_tc_Tango_mAttributeValue},
  {"errors", _0RL_tc_Tango_mDevErrorList}
};

static CORBA::TypeCode_ptr _0RL_tc_Tango_mDevAttrHistory = CORBA::TypeCode::PR_struct_tc("IDL:Tango/DevAttrHistory:1.0", "DevAttrHistory", _0RL_structmember_Tango_mDevAttrHistory, 3);



#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace Tango { 
  const CORBA::TypeCode_ptr _tc_DevAttrHistory = _0RL_tc_Tango_mDevAttrHistory;
} 
#else
const CORBA::TypeCode_ptr Tango::_tc_DevAttrHistory = _0RL_tc_Tango_mDevAttrHistory;
#endif


















static CORBA::TypeCode_ptr _0RL_tc_Tango_mDevAttrHistoryList = CORBA::TypeCode::PR_alias_tc("IDL:Tango/DevAttrHistoryList:1.0", "DevAttrHistoryList", CORBA::TypeCode::PR_sequence_tc(0, _0RL_tc_Tango_mDevAttrHistory));


#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace Tango { 
  const CORBA::TypeCode_ptr _tc_DevAttrHistoryList = _0RL_tc_Tango_mDevAttrHistoryList;
} 
#else
const CORBA::TypeCode_ptr Tango::_tc_DevAttrHistoryList = _0RL_tc_Tango_mDevAttrHistoryList;
#endif

#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace Tango { 
  const CORBA::TypeCode_ptr _tc_Device = CORBA::TypeCode::PR_interface_tc("IDL:Tango/Device:1.0", "Device");
} 
#else
const CORBA::TypeCode_ptr Tango::_tc_Device = CORBA::TypeCode::PR_interface_tc("IDL:Tango/Device:1.0", "Device");
#endif

#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace Tango { 
  const CORBA::TypeCode_ptr _tc_Device_2 = CORBA::TypeCode::PR_interface_tc("IDL:Tango/Device_2:1.0", "Device_2");
} 
#else
const CORBA::TypeCode_ptr Tango::_tc_Device_2 = CORBA::TypeCode::PR_interface_tc("IDL:Tango/Device_2:1.0", "Device_2");
#endif

#ifndef __0RL_tcParser_buildDesc_s0_cfloat__
#define __0RL_tcParser_buildDesc_s0_cfloat__
static void
_0RL_tcParser_setElementCount_s0_cfloat(const tcSequenceDesc* _desc, CORBA::ULong _len)
{
  ((_CORBA_Unbounded_Sequence_w_FixSizeElement< CORBA::Float, 4, 4 > *)_desc->opq_seq)->length(_len);
}

static CORBA::ULong
_0RL_tcParser_getElementCount_s0_cfloat(const tcSequenceDesc* _desc)
{
  return ((_CORBA_Unbounded_Sequence_w_FixSizeElement< CORBA::Float, 4, 4 > *)_desc->opq_seq)->length();
}

static CORBA::Boolean
_0RL_tcParser_getElementDesc_s0_cfloat(const tcSequenceDesc* _desc, CORBA::ULong _index, tcDescriptor& _newdesc, _CORBA_ULong& _contiguous)
{
  _newdesc.p_streamdata = ((_CORBA_Unbounded_Sequence_w_FixSizeElement< CORBA::Float, 4, 4 > *)_desc->opq_seq)->NP_data();
  _contiguous = ((_CORBA_Unbounded_Sequence_w_FixSizeElement< CORBA::Float, 4, 4 > *)_desc->opq_seq)->length() - _index;


  return 1;
}

static void
_0RL_buildDesc_s0_cfloat(tcDescriptor &_desc, const _CORBA_Unbounded_Sequence_w_FixSizeElement< CORBA::Float, 4, 4 > & _data)
{
  _desc.p_sequence.opq_seq = (void*) &_data;
  _desc.p_sequence.setElementCount =
    _0RL_tcParser_setElementCount_s0_cfloat;
  _desc.p_sequence.getElementCount =
    _0RL_tcParser_getElementCount_s0_cfloat;
  _desc.p_sequence.getElementDesc =
    _0RL_tcParser_getElementDesc_s0_cfloat;
  }
#endif

void operator <<= (CORBA::Any& _a, const Tango::DevVarFloatArray& _s)
{
  tcDescriptor tcdesc;
  _0RL_buildDesc_s0_cfloat(tcdesc, _s);
  _a.PR_packFrom(Tango::_tc_DevVarFloatArray, &tcdesc);
}

void _0RL_seq_delete_Tango_mDevVarFloatArray(void* _data)
{
  delete (Tango::DevVarFloatArray*)_data;
}

CORBA::Boolean operator >>= (const CORBA::Any& _a, Tango::DevVarFloatArray*& _s_out)
{
  return _a >>= (const Tango::DevVarFloatArray*&) _s_out;
}

CORBA::Boolean operator >>= (const CORBA::Any& _a, const Tango::DevVarFloatArray*& _s_out)
{
  _s_out = 0;
  Tango::DevVarFloatArray* stmp = (Tango::DevVarFloatArray*) _a.PR_getCachedData();
  if( stmp == 0 ) {
    tcDescriptor tcdesc;
    stmp = new Tango::DevVarFloatArray;
    _0RL_buildDesc_s0_cfloat(tcdesc, *stmp);
    if( _a.PR_unpackTo(Tango::_tc_DevVarFloatArray, &tcdesc)) {
      ((CORBA::Any*)&_a)->PR_setCachedData((void*)stmp, _0RL_seq_delete_Tango_mDevVarFloatArray);
      _s_out = stmp;
      return 1;
    } else {
      delete (Tango::DevVarFloatArray *)stmp;
      return 0;
    }
  } else {
    CORBA::TypeCode_var tctmp = _a.type();
    if( tctmp->equivalent(Tango::_tc_DevVarFloatArray) ) {
      _s_out = stmp;
      return 1;
    } else {
      return 0;
    }
  }
}

#ifndef __0RL_tcParser_buildDesc_s0_cdouble__
#define __0RL_tcParser_buildDesc_s0_cdouble__
static void
_0RL_tcParser_setElementCount_s0_cdouble(const tcSequenceDesc* _desc, CORBA::ULong _len)
{
  ((_CORBA_Unbounded_Sequence_w_FixSizeElement< CORBA::Double, 8, 8 > *)_desc->opq_seq)->length(_len);
}

static CORBA::ULong
_0RL_tcParser_getElementCount_s0_cdouble(const tcSequenceDesc* _desc)
{
  return ((_CORBA_Unbounded_Sequence_w_FixSizeElement< CORBA::Double, 8, 8 > *)_desc->opq_seq)->length();
}

static CORBA::Boolean
_0RL_tcParser_getElementDesc_s0_cdouble(const tcSequenceDesc* _desc, CORBA::ULong _index, tcDescriptor& _newdesc, _CORBA_ULong& _contiguous)
{
  _newdesc.p_streamdata = ((_CORBA_Unbounded_Sequence_w_FixSizeElement< CORBA::Double, 8, 8 > *)_desc->opq_seq)->NP_data();
  _contiguous = ((_CORBA_Unbounded_Sequence_w_FixSizeElement< CORBA::Double, 8, 8 > *)_desc->opq_seq)->length() - _index;


  return 1;
}

static void
_0RL_buildDesc_s0_cdouble(tcDescriptor &_desc, const _CORBA_Unbounded_Sequence_w_FixSizeElement< CORBA::Double, 8, 8 > & _data)
{
  _desc.p_sequence.opq_seq = (void*) &_data;
  _desc.p_sequence.setElementCount =
    _0RL_tcParser_setElementCount_s0_cdouble;
  _desc.p_sequence.getElementCount =
    _0RL_tcParser_getElementCount_s0_cdouble;
  _desc.p_sequence.getElementDesc =
    _0RL_tcParser_getElementDesc_s0_cdouble;
  }
#endif

void operator <<= (CORBA::Any& _a, const Tango::DevVarDoubleArray& _s)
{
  tcDescriptor tcdesc;
  _0RL_buildDesc_s0_cdouble(tcdesc, _s);
  _a.PR_packFrom(Tango::_tc_DevVarDoubleArray, &tcdesc);
}

void _0RL_seq_delete_Tango_mDevVarDoubleArray(void* _data)
{
  delete (Tango::DevVarDoubleArray*)_data;
}

CORBA::Boolean operator >>= (const CORBA::Any& _a, Tango::DevVarDoubleArray*& _s_out)
{
  return _a >>= (const Tango::DevVarDoubleArray*&) _s_out;
}

CORBA::Boolean operator >>= (const CORBA::Any& _a, const Tango::DevVarDoubleArray*& _s_out)
{
  _s_out = 0;
  Tango::DevVarDoubleArray* stmp = (Tango::DevVarDoubleArray*) _a.PR_getCachedData();
  if( stmp == 0 ) {
    tcDescriptor tcdesc;
    stmp = new Tango::DevVarDoubleArray;
    _0RL_buildDesc_s0_cdouble(tcdesc, *stmp);
    if( _a.PR_unpackTo(Tango::_tc_DevVarDoubleArray, &tcdesc)) {
      ((CORBA::Any*)&_a)->PR_setCachedData((void*)stmp, _0RL_seq_delete_Tango_mDevVarDoubleArray);
      _s_out = stmp;
      return 1;
    } else {
      delete (Tango::DevVarDoubleArray *)stmp;
      return 0;
    }
  } else {
    CORBA::TypeCode_var tctmp = _a.type();
    if( tctmp->equivalent(Tango::_tc_DevVarDoubleArray) ) {
      _s_out = stmp;
      return 1;
    } else {
      return 0;
    }
  }
}

#ifndef __0RL_tcParser_buildDesc_s0_cshort__
#define __0RL_tcParser_buildDesc_s0_cshort__
static void
_0RL_tcParser_setElementCount_s0_cshort(const tcSequenceDesc* _desc, CORBA::ULong _len)
{
  ((_CORBA_Unbounded_Sequence_w_FixSizeElement< CORBA::Short, 2, 2 > *)_desc->opq_seq)->length(_len);
}

static CORBA::ULong
_0RL_tcParser_getElementCount_s0_cshort(const tcSequenceDesc* _desc)
{
  return ((_CORBA_Unbounded_Sequence_w_FixSizeElement< CORBA::Short, 2, 2 > *)_desc->opq_seq)->length();
}

static CORBA::Boolean
_0RL_tcParser_getElementDesc_s0_cshort(const tcSequenceDesc* _desc, CORBA::ULong _index, tcDescriptor& _newdesc, _CORBA_ULong& _contiguous)
{
  _newdesc.p_streamdata = ((_CORBA_Unbounded_Sequence_w_FixSizeElement< CORBA::Short, 2, 2 > *)_desc->opq_seq)->NP_data();
  _contiguous = ((_CORBA_Unbounded_Sequence_w_FixSizeElement< CORBA::Short, 2, 2 > *)_desc->opq_seq)->length() - _index;


  return 1;
}

static void
_0RL_buildDesc_s0_cshort(tcDescriptor &_desc, const _CORBA_Unbounded_Sequence_w_FixSizeElement< CORBA::Short, 2, 2 > & _data)
{
  _desc.p_sequence.opq_seq = (void*) &_data;
  _desc.p_sequence.setElementCount =
    _0RL_tcParser_setElementCount_s0_cshort;
  _desc.p_sequence.getElementCount =
    _0RL_tcParser_getElementCount_s0_cshort;
  _desc.p_sequence.getElementDesc =
    _0RL_tcParser_getElementDesc_s0_cshort;
  }
#endif

void operator <<= (CORBA::Any& _a, const Tango::DevVarShortArray& _s)
{
  tcDescriptor tcdesc;
  _0RL_buildDesc_s0_cshort(tcdesc, _s);
  _a.PR_packFrom(Tango::_tc_DevVarShortArray, &tcdesc);
}

void _0RL_seq_delete_Tango_mDevVarShortArray(void* _data)
{
  delete (Tango::DevVarShortArray*)_data;
}

CORBA::Boolean operator >>= (const CORBA::Any& _a, Tango::DevVarShortArray*& _s_out)
{
  return _a >>= (const Tango::DevVarShortArray*&) _s_out;
}

CORBA::Boolean operator >>= (const CORBA::Any& _a, const Tango::DevVarShortArray*& _s_out)
{
  _s_out = 0;
  Tango::DevVarShortArray* stmp = (Tango::DevVarShortArray*) _a.PR_getCachedData();
  if( stmp == 0 ) {
    tcDescriptor tcdesc;
    stmp = new Tango::DevVarShortArray;
    _0RL_buildDesc_s0_cshort(tcdesc, *stmp);
    if( _a.PR_unpackTo(Tango::_tc_DevVarShortArray, &tcdesc)) {
      ((CORBA::Any*)&_a)->PR_setCachedData((void*)stmp, _0RL_seq_delete_Tango_mDevVarShortArray);
      _s_out = stmp;
      return 1;
    } else {
      delete (Tango::DevVarShortArray *)stmp;
      return 0;
    }
  } else {
    CORBA::TypeCode_var tctmp = _a.type();
    if( tctmp->equivalent(Tango::_tc_DevVarShortArray) ) {
      _s_out = stmp;
      return 1;
    } else {
      return 0;
    }
  }
}

#ifndef __0RL_tcParser_buildDesc_s0_clong__
#define __0RL_tcParser_buildDesc_s0_clong__
static void
_0RL_tcParser_setElementCount_s0_clong(const tcSequenceDesc* _desc, CORBA::ULong _len)
{
  ((_CORBA_Unbounded_Sequence_w_FixSizeElement< CORBA::Long, 4, 4 > *)_desc->opq_seq)->length(_len);
}

static CORBA::ULong
_0RL_tcParser_getElementCount_s0_clong(const tcSequenceDesc* _desc)
{
  return ((_CORBA_Unbounded_Sequence_w_FixSizeElement< CORBA::Long, 4, 4 > *)_desc->opq_seq)->length();
}

static CORBA::Boolean
_0RL_tcParser_getElementDesc_s0_clong(const tcSequenceDesc* _desc, CORBA::ULong _index, tcDescriptor& _newdesc, _CORBA_ULong& _contiguous)
{
  _newdesc.p_streamdata = ((_CORBA_Unbounded_Sequence_w_FixSizeElement< CORBA::Long, 4, 4 > *)_desc->opq_seq)->NP_data();
  _contiguous = ((_CORBA_Unbounded_Sequence_w_FixSizeElement< CORBA::Long, 4, 4 > *)_desc->opq_seq)->length() - _index;


  return 1;
}

static void
_0RL_buildDesc_s0_clong(tcDescriptor &_desc, const _CORBA_Unbounded_Sequence_w_FixSizeElement< CORBA::Long, 4, 4 > & _data)
{
  _desc.p_sequence.opq_seq = (void*) &_data;
  _desc.p_sequence.setElementCount =
    _0RL_tcParser_setElementCount_s0_clong;
  _desc.p_sequence.getElementCount =
    _0RL_tcParser_getElementCount_s0_clong;
  _desc.p_sequence.getElementDesc =
    _0RL_tcParser_getElementDesc_s0_clong;
  }
#endif

void operator <<= (CORBA::Any& _a, const Tango::DevVarLongArray& _s)
{
  tcDescriptor tcdesc;
  _0RL_buildDesc_s0_clong(tcdesc, _s);
  _a.PR_packFrom(Tango::_tc_DevVarLongArray, &tcdesc);
}

void _0RL_seq_delete_Tango_mDevVarLongArray(void* _data)
{
  delete (Tango::DevVarLongArray*)_data;
}

CORBA::Boolean operator >>= (const CORBA::Any& _a, Tango::DevVarLongArray*& _s_out)
{
  return _a >>= (const Tango::DevVarLongArray*&) _s_out;
}

CORBA::Boolean operator >>= (const CORBA::Any& _a, const Tango::DevVarLongArray*& _s_out)
{
  _s_out = 0;
  Tango::DevVarLongArray* stmp = (Tango::DevVarLongArray*) _a.PR_getCachedData();
  if( stmp == 0 ) {
    tcDescriptor tcdesc;
    stmp = new Tango::DevVarLongArray;
    _0RL_buildDesc_s0_clong(tcdesc, *stmp);
    if( _a.PR_unpackTo(Tango::_tc_DevVarLongArray, &tcdesc)) {
      ((CORBA::Any*)&_a)->PR_setCachedData((void*)stmp, _0RL_seq_delete_Tango_mDevVarLongArray);
      _s_out = stmp;
      return 1;
    } else {
      delete (Tango::DevVarLongArray *)stmp;
      return 0;
    }
  } else {
    CORBA::TypeCode_var tctmp = _a.type();
    if( tctmp->equivalent(Tango::_tc_DevVarLongArray) ) {
      _s_out = stmp;
      return 1;
    } else {
      return 0;
    }
  }
}

#ifndef __0RL_tcParser_buildDesc_s0_coctet__
#define __0RL_tcParser_buildDesc_s0_coctet__
static void
_0RL_tcParser_setElementCount_s0_coctet(const tcSequenceDesc* _desc, CORBA::ULong _len)
{
  ((_CORBA_Unbounded_Sequence_Octet*)_desc->opq_seq)->length(_len);
}

static CORBA::ULong
_0RL_tcParser_getElementCount_s0_coctet(const tcSequenceDesc* _desc)
{
  return ((_CORBA_Unbounded_Sequence_Octet*)_desc->opq_seq)->length();
}

static CORBA::Boolean
_0RL_tcParser_getElementDesc_s0_coctet(const tcSequenceDesc* _desc, CORBA::ULong _index, tcDescriptor& _newdesc, _CORBA_ULong& _contiguous)
{
  _newdesc.p_streamdata = ((_CORBA_Unbounded_Sequence_Octet*)_desc->opq_seq)->NP_data();
  _contiguous = ((_CORBA_Unbounded_Sequence_Octet*)_desc->opq_seq)->length() - _index;


  return 1;
}

static void
_0RL_buildDesc_s0_coctet(tcDescriptor &_desc, const _CORBA_Unbounded_Sequence_Octet& _data)
{
  _desc.p_sequence.opq_seq = (void*) &_data;
  _desc.p_sequence.setElementCount =
    _0RL_tcParser_setElementCount_s0_coctet;
  _desc.p_sequence.getElementCount =
    _0RL_tcParser_getElementCount_s0_coctet;
  _desc.p_sequence.getElementDesc =
    _0RL_tcParser_getElementDesc_s0_coctet;
  }
#endif

void operator <<= (CORBA::Any& _a, const Tango::DevVarCharArray& _s)
{
  tcDescriptor tcdesc;
  _0RL_buildDesc_s0_coctet(tcdesc, _s);
  _a.PR_packFrom(Tango::_tc_DevVarCharArray, &tcdesc);
}

void _0RL_seq_delete_Tango_mDevVarCharArray(void* _data)
{
  delete (Tango::DevVarCharArray*)_data;
}

CORBA::Boolean operator >>= (const CORBA::Any& _a, Tango::DevVarCharArray*& _s_out)
{
  return _a >>= (const Tango::DevVarCharArray*&) _s_out;
}

CORBA::Boolean operator >>= (const CORBA::Any& _a, const Tango::DevVarCharArray*& _s_out)
{
  _s_out = 0;
  Tango::DevVarCharArray* stmp = (Tango::DevVarCharArray*) _a.PR_getCachedData();
  if( stmp == 0 ) {
    tcDescriptor tcdesc;
    stmp = new Tango::DevVarCharArray;
    _0RL_buildDesc_s0_coctet(tcdesc, *stmp);
    if( _a.PR_unpackTo(Tango::_tc_DevVarCharArray, &tcdesc)) {
      ((CORBA::Any*)&_a)->PR_setCachedData((void*)stmp, _0RL_seq_delete_Tango_mDevVarCharArray);
      _s_out = stmp;
      return 1;
    } else {
      delete (Tango::DevVarCharArray *)stmp;
      return 0;
    }
  } else {
    CORBA::TypeCode_var tctmp = _a.type();
    if( tctmp->equivalent(Tango::_tc_DevVarCharArray) ) {
      _s_out = stmp;
      return 1;
    } else {
      return 0;
    }
  }
}

#ifndef __0RL_tcParser_buildDesc_s0_cstring__
#define __0RL_tcParser_buildDesc_s0_cstring__
static void
_0RL_tcParser_setElementCount_s0_cstring(const tcSequenceDesc* _desc, CORBA::ULong _len)
{
  ((_CORBA_Unbounded_Sequence_String*)_desc->opq_seq)->length(_len);
}

static CORBA::ULong
_0RL_tcParser_getElementCount_s0_cstring(const tcSequenceDesc* _desc)
{
  return ((_CORBA_Unbounded_Sequence_String*)_desc->opq_seq)->length();
}

static CORBA::Boolean
_0RL_tcParser_getElementDesc_s0_cstring(const tcSequenceDesc* _desc, CORBA::ULong _index, tcDescriptor& _newdesc, _CORBA_ULong& _contiguous)
{
  _0RL_buildDesc_cstring(_newdesc, (*((_CORBA_Unbounded_Sequence_String*)_desc->opq_seq))[_index]);


  return 1;
}

static void
_0RL_buildDesc_s0_cstring(tcDescriptor &_desc, const _CORBA_Unbounded_Sequence_String& _data)
{
  _desc.p_sequence.opq_seq = (void*) &_data;
  _desc.p_sequence.setElementCount =
    _0RL_tcParser_setElementCount_s0_cstring;
  _desc.p_sequence.getElementCount =
    _0RL_tcParser_getElementCount_s0_cstring;
  _desc.p_sequence.getElementDesc =
    _0RL_tcParser_getElementDesc_s0_cstring;
  }
#endif

void operator <<= (CORBA::Any& _a, const Tango::DevVarStringArray& _s)
{
  tcDescriptor tcdesc;
  _0RL_buildDesc_s0_cstring(tcdesc, _s);
  _a.PR_packFrom(Tango::_tc_DevVarStringArray, &tcdesc);
}

void _0RL_seq_delete_Tango_mDevVarStringArray(void* _data)
{
  delete (Tango::DevVarStringArray*)_data;
}

CORBA::Boolean operator >>= (const CORBA::Any& _a, Tango::DevVarStringArray*& _s_out)
{
  return _a >>= (const Tango::DevVarStringArray*&) _s_out;
}

CORBA::Boolean operator >>= (const CORBA::Any& _a, const Tango::DevVarStringArray*& _s_out)
{
  _s_out = 0;
  Tango::DevVarStringArray* stmp = (Tango::DevVarStringArray*) _a.PR_getCachedData();
  if( stmp == 0 ) {
    tcDescriptor tcdesc;
    stmp = new Tango::DevVarStringArray;
    _0RL_buildDesc_s0_cstring(tcdesc, *stmp);
    if( _a.PR_unpackTo(Tango::_tc_DevVarStringArray, &tcdesc)) {
      ((CORBA::Any*)&_a)->PR_setCachedData((void*)stmp, _0RL_seq_delete_Tango_mDevVarStringArray);
      _s_out = stmp;
      return 1;
    } else {
      delete (Tango::DevVarStringArray *)stmp;
      return 0;
    }
  } else {
    CORBA::TypeCode_var tctmp = _a.type();
    if( tctmp->equivalent(Tango::_tc_DevVarStringArray) ) {
      _s_out = stmp;
      return 1;
    } else {
      return 0;
    }
  }
}

#ifndef __0RL_tcParser_buildDesc_s0_cunsigned_pshort__
#define __0RL_tcParser_buildDesc_s0_cunsigned_pshort__
static void
_0RL_tcParser_setElementCount_s0_cunsigned_pshort(const tcSequenceDesc* _desc, CORBA::ULong _len)
{
  ((_CORBA_Unbounded_Sequence_w_FixSizeElement< CORBA::UShort, 2, 2 > *)_desc->opq_seq)->length(_len);
}

static CORBA::ULong
_0RL_tcParser_getElementCount_s0_cunsigned_pshort(const tcSequenceDesc* _desc)
{
  return ((_CORBA_Unbounded_Sequence_w_FixSizeElement< CORBA::UShort, 2, 2 > *)_desc->opq_seq)->length();
}

static CORBA::Boolean
_0RL_tcParser_getElementDesc_s0_cunsigned_pshort(const tcSequenceDesc* _desc, CORBA::ULong _index, tcDescriptor& _newdesc, _CORBA_ULong& _contiguous)
{
  _newdesc.p_streamdata = ((_CORBA_Unbounded_Sequence_w_FixSizeElement< CORBA::UShort, 2, 2 > *)_desc->opq_seq)->NP_data();
  _contiguous = ((_CORBA_Unbounded_Sequence_w_FixSizeElement< CORBA::UShort, 2, 2 > *)_desc->opq_seq)->length() - _index;


  return 1;
}

static void
_0RL_buildDesc_s0_cunsigned_pshort(tcDescriptor &_desc, const _CORBA_Unbounded_Sequence_w_FixSizeElement< CORBA::UShort, 2, 2 > & _data)
{
  _desc.p_sequence.opq_seq = (void*) &_data;
  _desc.p_sequence.setElementCount =
    _0RL_tcParser_setElementCount_s0_cunsigned_pshort;
  _desc.p_sequence.getElementCount =
    _0RL_tcParser_getElementCount_s0_cunsigned_pshort;
  _desc.p_sequence.getElementDesc =
    _0RL_tcParser_getElementDesc_s0_cunsigned_pshort;
  }
#endif

void operator <<= (CORBA::Any& _a, const Tango::DevVarUShortArray& _s)
{
  tcDescriptor tcdesc;
  _0RL_buildDesc_s0_cunsigned_pshort(tcdesc, _s);
  _a.PR_packFrom(Tango::_tc_DevVarUShortArray, &tcdesc);
}

void _0RL_seq_delete_Tango_mDevVarUShortArray(void* _data)
{
  delete (Tango::DevVarUShortArray*)_data;
}

CORBA::Boolean operator >>= (const CORBA::Any& _a, Tango::DevVarUShortArray*& _s_out)
{
  return _a >>= (const Tango::DevVarUShortArray*&) _s_out;
}

CORBA::Boolean operator >>= (const CORBA::Any& _a, const Tango::DevVarUShortArray*& _s_out)
{
  _s_out = 0;
  Tango::DevVarUShortArray* stmp = (Tango::DevVarUShortArray*) _a.PR_getCachedData();
  if( stmp == 0 ) {
    tcDescriptor tcdesc;
    stmp = new Tango::DevVarUShortArray;
    _0RL_buildDesc_s0_cunsigned_pshort(tcdesc, *stmp);
    if( _a.PR_unpackTo(Tango::_tc_DevVarUShortArray, &tcdesc)) {
      ((CORBA::Any*)&_a)->PR_setCachedData((void*)stmp, _0RL_seq_delete_Tango_mDevVarUShortArray);
      _s_out = stmp;
      return 1;
    } else {
      delete (Tango::DevVarUShortArray *)stmp;
      return 0;
    }
  } else {
    CORBA::TypeCode_var tctmp = _a.type();
    if( tctmp->equivalent(Tango::_tc_DevVarUShortArray) ) {
      _s_out = stmp;
      return 1;
    } else {
      return 0;
    }
  }
}

#ifndef __0RL_tcParser_buildDesc_s0_cunsigned_plong__
#define __0RL_tcParser_buildDesc_s0_cunsigned_plong__
static void
_0RL_tcParser_setElementCount_s0_cunsigned_plong(const tcSequenceDesc* _desc, CORBA::ULong _len)
{
  ((_CORBA_Unbounded_Sequence_w_FixSizeElement< CORBA::ULong, 4, 4 > *)_desc->opq_seq)->length(_len);
}

static CORBA::ULong
_0RL_tcParser_getElementCount_s0_cunsigned_plong(const tcSequenceDesc* _desc)
{
  return ((_CORBA_Unbounded_Sequence_w_FixSizeElement< CORBA::ULong, 4, 4 > *)_desc->opq_seq)->length();
}

static CORBA::Boolean
_0RL_tcParser_getElementDesc_s0_cunsigned_plong(const tcSequenceDesc* _desc, CORBA::ULong _index, tcDescriptor& _newdesc, _CORBA_ULong& _contiguous)
{
  _newdesc.p_streamdata = ((_CORBA_Unbounded_Sequence_w_FixSizeElement< CORBA::ULong, 4, 4 > *)_desc->opq_seq)->NP_data();
  _contiguous = ((_CORBA_Unbounded_Sequence_w_FixSizeElement< CORBA::ULong, 4, 4 > *)_desc->opq_seq)->length() - _index;


  return 1;
}

static void
_0RL_buildDesc_s0_cunsigned_plong(tcDescriptor &_desc, const _CORBA_Unbounded_Sequence_w_FixSizeElement< CORBA::ULong, 4, 4 > & _data)
{
  _desc.p_sequence.opq_seq = (void*) &_data;
  _desc.p_sequence.setElementCount =
    _0RL_tcParser_setElementCount_s0_cunsigned_plong;
  _desc.p_sequence.getElementCount =
    _0RL_tcParser_getElementCount_s0_cunsigned_plong;
  _desc.p_sequence.getElementDesc =
    _0RL_tcParser_getElementDesc_s0_cunsigned_plong;
  }
#endif

void operator <<= (CORBA::Any& _a, const Tango::DevVarULongArray& _s)
{
  tcDescriptor tcdesc;
  _0RL_buildDesc_s0_cunsigned_plong(tcdesc, _s);
  _a.PR_packFrom(Tango::_tc_DevVarULongArray, &tcdesc);
}

void _0RL_seq_delete_Tango_mDevVarULongArray(void* _data)
{
  delete (Tango::DevVarULongArray*)_data;
}

CORBA::Boolean operator >>= (const CORBA::Any& _a, Tango::DevVarULongArray*& _s_out)
{
  return _a >>= (const Tango::DevVarULongArray*&) _s_out;
}

CORBA::Boolean operator >>= (const CORBA::Any& _a, const Tango::DevVarULongArray*& _s_out)
{
  _s_out = 0;
  Tango::DevVarULongArray* stmp = (Tango::DevVarULongArray*) _a.PR_getCachedData();
  if( stmp == 0 ) {
    tcDescriptor tcdesc;
    stmp = new Tango::DevVarULongArray;
    _0RL_buildDesc_s0_cunsigned_plong(tcdesc, *stmp);
    if( _a.PR_unpackTo(Tango::_tc_DevVarULongArray, &tcdesc)) {
      ((CORBA::Any*)&_a)->PR_setCachedData((void*)stmp, _0RL_seq_delete_Tango_mDevVarULongArray);
      _s_out = stmp;
      return 1;
    } else {
      delete (Tango::DevVarULongArray *)stmp;
      return 0;
    }
  } else {
    CORBA::TypeCode_var tctmp = _a.type();
    if( tctmp->equivalent(Tango::_tc_DevVarULongArray) ) {
      _s_out = stmp;
      return 1;
    } else {
      return 0;
    }
  }
}

void _0RL_delete_Tango_mDevVarLongStringArray(void* _data) {
  Tango::DevVarLongStringArray* _0RL_t = (Tango::DevVarLongStringArray*) _data;
  delete _0RL_t;
}

static CORBA::Boolean
_0RL_tcParser_getMemberDesc_Tango_mDevVarLongStringArray(const tcStructDesc *_desc, CORBA::ULong _index, tcDescriptor &_newdesc){
  switch (_index) {
  case 0:
    _0RL_buildDesc_s0_clong(_newdesc, ((Tango::DevVarLongStringArray*)_desc->opq_struct)->lvalue);
    return 1;
  case 1:
    _0RL_buildDesc_s0_cstring(_newdesc, ((Tango::DevVarLongStringArray*)_desc->opq_struct)->svalue);
    return 1;

  default:
    return 0;
  };
}
static CORBA::ULong

_0RL_tcParser_getMemberCount_Tango_mDevVarLongStringArray(const tcStructDesc *_desc)
{
  return 2;
}

void _0RL_buildDesc_cTango_mDevVarLongStringArray(tcDescriptor &_desc, const Tango::DevVarLongStringArray& _data)
{
  _desc.p_struct.getMemberDesc = _0RL_tcParser_getMemberDesc_Tango_mDevVarLongStringArray;
  _desc.p_struct.getMemberCount = _0RL_tcParser_getMemberCount_Tango_mDevVarLongStringArray;
  _desc.p_struct.opq_struct = (void *)&_data;
}



void operator<<=(CORBA::Any& _a, const Tango::DevVarLongStringArray& _s) {
  tcDescriptor _0RL_tcdesc;
  _0RL_buildDesc_cTango_mDevVarLongStringArray(_0RL_tcdesc, _s);
  _a.PR_packFrom(_0RL_tc_Tango_mDevVarLongStringArray, &_0RL_tcdesc);
}
 
void operator<<=(CORBA::Any& _a, Tango::DevVarLongStringArray* _sp) {
  tcDescriptor _0RL_tcdesc;
  _0RL_buildDesc_cTango_mDevVarLongStringArray(_0RL_tcdesc, *_sp);
  _a.PR_packFrom(_0RL_tc_Tango_mDevVarLongStringArray, &_0RL_tcdesc);
  delete _sp;
}

CORBA::Boolean operator>>=(const CORBA::Any& _a, Tango::DevVarLongStringArray*& _sp) {
  return _a >>= (const Tango::DevVarLongStringArray*&) _sp;
}

CORBA::Boolean operator>>=(const CORBA::Any& _a, const Tango::DevVarLongStringArray*& _sp) {
  _sp = (Tango::DevVarLongStringArray *) _a.PR_getCachedData();
  if (_sp == 0) {
    tcDescriptor _0RL_tcdesc;
    _sp = new Tango::DevVarLongStringArray;
    _0RL_buildDesc_cTango_mDevVarLongStringArray(_0RL_tcdesc, *_sp);
    if (_a.PR_unpackTo(_0RL_tc_Tango_mDevVarLongStringArray, &_0RL_tcdesc)) {
      ((CORBA::Any *)&_a)->PR_setCachedData((void*)_sp, _0RL_delete_Tango_mDevVarLongStringArray);
      return 1;
    } else {
      delete (Tango::DevVarLongStringArray *)_sp; _sp = 0;
      return 0;
    }
  } else {
    CORBA::TypeCode_var _0RL_tctmp = _a.type();
    if (_0RL_tctmp->equivalent(_0RL_tc_Tango_mDevVarLongStringArray)) return 1;
    _sp = 0;
    return 0;
  }
}
void _0RL_delete_Tango_mDevVarDoubleStringArray(void* _data) {
  Tango::DevVarDoubleStringArray* _0RL_t = (Tango::DevVarDoubleStringArray*) _data;
  delete _0RL_t;
}

static CORBA::Boolean
_0RL_tcParser_getMemberDesc_Tango_mDevVarDoubleStringArray(const tcStructDesc *_desc, CORBA::ULong _index, tcDescriptor &_newdesc){
  switch (_index) {
  case 0:
    _0RL_buildDesc_s0_cdouble(_newdesc, ((Tango::DevVarDoubleStringArray*)_desc->opq_struct)->dvalue);
    return 1;
  case 1:
    _0RL_buildDesc_s0_cstring(_newdesc, ((Tango::DevVarDoubleStringArray*)_desc->opq_struct)->svalue);
    return 1;

  default:
    return 0;
  };
}
static CORBA::ULong

_0RL_tcParser_getMemberCount_Tango_mDevVarDoubleStringArray(const tcStructDesc *_desc)
{
  return 2;
}

void _0RL_buildDesc_cTango_mDevVarDoubleStringArray(tcDescriptor &_desc, const Tango::DevVarDoubleStringArray& _data)
{
  _desc.p_struct.getMemberDesc = _0RL_tcParser_getMemberDesc_Tango_mDevVarDoubleStringArray;
  _desc.p_struct.getMemberCount = _0RL_tcParser_getMemberCount_Tango_mDevVarDoubleStringArray;
  _desc.p_struct.opq_struct = (void *)&_data;
}



void operator<<=(CORBA::Any& _a, const Tango::DevVarDoubleStringArray& _s) {
  tcDescriptor _0RL_tcdesc;
  _0RL_buildDesc_cTango_mDevVarDoubleStringArray(_0RL_tcdesc, _s);
  _a.PR_packFrom(_0RL_tc_Tango_mDevVarDoubleStringArray, &_0RL_tcdesc);
}
 
void operator<<=(CORBA::Any& _a, Tango::DevVarDoubleStringArray* _sp) {
  tcDescriptor _0RL_tcdesc;
  _0RL_buildDesc_cTango_mDevVarDoubleStringArray(_0RL_tcdesc, *_sp);
  _a.PR_packFrom(_0RL_tc_Tango_mDevVarDoubleStringArray, &_0RL_tcdesc);
  delete _sp;
}

CORBA::Boolean operator>>=(const CORBA::Any& _a, Tango::DevVarDoubleStringArray*& _sp) {
  return _a >>= (const Tango::DevVarDoubleStringArray*&) _sp;
}

CORBA::Boolean operator>>=(const CORBA::Any& _a, const Tango::DevVarDoubleStringArray*& _sp) {
  _sp = (Tango::DevVarDoubleStringArray *) _a.PR_getCachedData();
  if (_sp == 0) {
    tcDescriptor _0RL_tcdesc;
    _sp = new Tango::DevVarDoubleStringArray;
    _0RL_buildDesc_cTango_mDevVarDoubleStringArray(_0RL_tcdesc, *_sp);
    if (_a.PR_unpackTo(_0RL_tc_Tango_mDevVarDoubleStringArray, &_0RL_tcdesc)) {
      ((CORBA::Any *)&_a)->PR_setCachedData((void*)_sp, _0RL_delete_Tango_mDevVarDoubleStringArray);
      return 1;
    } else {
      delete (Tango::DevVarDoubleStringArray *)_sp; _sp = 0;
      return 0;
    }
  } else {
    CORBA::TypeCode_var _0RL_tctmp = _a.type();
    if (_0RL_tctmp->equivalent(_0RL_tc_Tango_mDevVarDoubleStringArray)) return 1;
    _sp = 0;
    return 0;
  }
}
void _0RL_buildDesc_cTango_mAttrQuality(tcDescriptor& _desc, const Tango::AttrQuality& _data)
{
  _desc.p_enum.data = (void*)&_data;
  _desc.p_enum.size = sizeof(_data);
}

void operator<<=(CORBA::Any& _a, Tango::AttrQuality _s)
{
  tcDescriptor _0RL_tcd;
  _0RL_buildDesc_cTango_mAttrQuality(_0RL_tcd, _s);
  _a.PR_packFrom(_0RL_tc_Tango_mAttrQuality, &_0RL_tcd);
}

CORBA::Boolean operator>>=(const CORBA::Any& _a, Tango::AttrQuality& _s)
{
  tcDescriptor _0RL_tcd;
  _0RL_buildDesc_cTango_mAttrQuality(_0RL_tcd, _s);
  return _a.PR_unpackTo(_0RL_tc_Tango_mAttrQuality, &_0RL_tcd);
}

void _0RL_buildDesc_cTango_mAttrWriteType(tcDescriptor& _desc, const Tango::AttrWriteType& _data)
{
  _desc.p_enum.data = (void*)&_data;
  _desc.p_enum.size = sizeof(_data);
}

void operator<<=(CORBA::Any& _a, Tango::AttrWriteType _s)
{
  tcDescriptor _0RL_tcd;
  _0RL_buildDesc_cTango_mAttrWriteType(_0RL_tcd, _s);
  _a.PR_packFrom(_0RL_tc_Tango_mAttrWriteType, &_0RL_tcd);
}

CORBA::Boolean operator>>=(const CORBA::Any& _a, Tango::AttrWriteType& _s)
{
  tcDescriptor _0RL_tcd;
  _0RL_buildDesc_cTango_mAttrWriteType(_0RL_tcd, _s);
  return _a.PR_unpackTo(_0RL_tc_Tango_mAttrWriteType, &_0RL_tcd);
}

void _0RL_buildDesc_cTango_mAttrDataFormat(tcDescriptor& _desc, const Tango::AttrDataFormat& _data)
{
  _desc.p_enum.data = (void*)&_data;
  _desc.p_enum.size = sizeof(_data);
}

void operator<<=(CORBA::Any& _a, Tango::AttrDataFormat _s)
{
  tcDescriptor _0RL_tcd;
  _0RL_buildDesc_cTango_mAttrDataFormat(_0RL_tcd, _s);
  _a.PR_packFrom(_0RL_tc_Tango_mAttrDataFormat, &_0RL_tcd);
}

CORBA::Boolean operator>>=(const CORBA::Any& _a, Tango::AttrDataFormat& _s)
{
  tcDescriptor _0RL_tcd;
  _0RL_buildDesc_cTango_mAttrDataFormat(_0RL_tcd, _s);
  return _a.PR_unpackTo(_0RL_tc_Tango_mAttrDataFormat, &_0RL_tcd);
}

void _0RL_buildDesc_cTango_mDevSource(tcDescriptor& _desc, const Tango::DevSource& _data)
{
  _desc.p_enum.data = (void*)&_data;
  _desc.p_enum.size = sizeof(_data);
}

void operator<<=(CORBA::Any& _a, Tango::DevSource _s)
{
  tcDescriptor _0RL_tcd;
  _0RL_buildDesc_cTango_mDevSource(_0RL_tcd, _s);
  _a.PR_packFrom(_0RL_tc_Tango_mDevSource, &_0RL_tcd);
}

CORBA::Boolean operator>>=(const CORBA::Any& _a, Tango::DevSource& _s)
{
  tcDescriptor _0RL_tcd;
  _0RL_buildDesc_cTango_mDevSource(_0RL_tcd, _s);
  return _a.PR_unpackTo(_0RL_tc_Tango_mDevSource, &_0RL_tcd);
}

void _0RL_buildDesc_cTango_mErrSeverity(tcDescriptor& _desc, const Tango::ErrSeverity& _data)
{
  _desc.p_enum.data = (void*)&_data;
  _desc.p_enum.size = sizeof(_data);
}

void operator<<=(CORBA::Any& _a, Tango::ErrSeverity _s)
{
  tcDescriptor _0RL_tcd;
  _0RL_buildDesc_cTango_mErrSeverity(_0RL_tcd, _s);
  _a.PR_packFrom(_0RL_tc_Tango_mErrSeverity, &_0RL_tcd);
}

CORBA::Boolean operator>>=(const CORBA::Any& _a, Tango::ErrSeverity& _s)
{
  tcDescriptor _0RL_tcd;
  _0RL_buildDesc_cTango_mErrSeverity(_0RL_tcd, _s);
  return _a.PR_unpackTo(_0RL_tc_Tango_mErrSeverity, &_0RL_tcd);
}

void _0RL_buildDesc_cTango_mDevState(tcDescriptor& _desc, const Tango::DevState& _data)
{
  _desc.p_enum.data = (void*)&_data;
  _desc.p_enum.size = sizeof(_data);
}

void operator<<=(CORBA::Any& _a, Tango::DevState _s)
{
  tcDescriptor _0RL_tcd;
  _0RL_buildDesc_cTango_mDevState(_0RL_tcd, _s);
  _a.PR_packFrom(_0RL_tc_Tango_mDevState, &_0RL_tcd);
}

CORBA::Boolean operator>>=(const CORBA::Any& _a, Tango::DevState& _s)
{
  tcDescriptor _0RL_tcd;
  _0RL_buildDesc_cTango_mDevState(_0RL_tcd, _s);
  return _a.PR_unpackTo(_0RL_tc_Tango_mDevState, &_0RL_tcd);
}

void _0RL_buildDesc_cTango_mDispLevel(tcDescriptor& _desc, const Tango::DispLevel& _data)
{
  _desc.p_enum.data = (void*)&_data;
  _desc.p_enum.size = sizeof(_data);
}

void operator<<=(CORBA::Any& _a, Tango::DispLevel _s)
{
  tcDescriptor _0RL_tcd;
  _0RL_buildDesc_cTango_mDispLevel(_0RL_tcd, _s);
  _a.PR_packFrom(_0RL_tc_Tango_mDispLevel, &_0RL_tcd);
}

CORBA::Boolean operator>>=(const CORBA::Any& _a, Tango::DispLevel& _s)
{
  tcDescriptor _0RL_tcd;
  _0RL_buildDesc_cTango_mDispLevel(_0RL_tcd, _s);
  return _a.PR_unpackTo(_0RL_tc_Tango_mDispLevel, &_0RL_tcd);
}

void _0RL_delete_Tango_mTimeVal(void* _data) {
  Tango::TimeVal* _0RL_t = (Tango::TimeVal*) _data;
  delete _0RL_t;
}

static CORBA::Boolean
_0RL_tcParser_getMemberDesc_Tango_mTimeVal(const tcStructDesc *_desc, CORBA::ULong _index, tcDescriptor &_newdesc){
  switch (_index) {
  case 0:
    _0RL_buildDesc_clong(_newdesc, ((Tango::TimeVal*)_desc->opq_struct)->tv_sec);
    return 1;
  case 1:
    _0RL_buildDesc_clong(_newdesc, ((Tango::TimeVal*)_desc->opq_struct)->tv_usec);
    return 1;
  case 2:
    _0RL_buildDesc_clong(_newdesc, ((Tango::TimeVal*)_desc->opq_struct)->tv_nsec);
    return 1;

  default:
    return 0;
  };
}
static CORBA::ULong

_0RL_tcParser_getMemberCount_Tango_mTimeVal(const tcStructDesc *_desc)
{
  return 3;
}

void _0RL_buildDesc_cTango_mTimeVal(tcDescriptor &_desc, const Tango::TimeVal& _data)
{
  _desc.p_struct.getMemberDesc = _0RL_tcParser_getMemberDesc_Tango_mTimeVal;
  _desc.p_struct.getMemberCount = _0RL_tcParser_getMemberCount_Tango_mTimeVal;
  _desc.p_struct.opq_struct = (void *)&_data;
}



void operator<<=(CORBA::Any& _a, const Tango::TimeVal& _s) {
  tcDescriptor _0RL_tcdesc;
  _0RL_buildDesc_cTango_mTimeVal(_0RL_tcdesc, _s);
  _a.PR_packFrom(_0RL_tc_Tango_mTimeVal, &_0RL_tcdesc);
}
 
void operator<<=(CORBA::Any& _a, Tango::TimeVal* _sp) {
  tcDescriptor _0RL_tcdesc;
  _0RL_buildDesc_cTango_mTimeVal(_0RL_tcdesc, *_sp);
  _a.PR_packFrom(_0RL_tc_Tango_mTimeVal, &_0RL_tcdesc);
  delete _sp;
}

CORBA::Boolean operator>>=(const CORBA::Any& _a, Tango::TimeVal*& _sp) {
  return _a >>= (const Tango::TimeVal*&) _sp;
}

CORBA::Boolean operator>>=(const CORBA::Any& _a, const Tango::TimeVal*& _sp) {
  _sp = (Tango::TimeVal *) _a.PR_getCachedData();
  if (_sp == 0) {
    tcDescriptor _0RL_tcdesc;
    _sp = new Tango::TimeVal;
    _0RL_buildDesc_cTango_mTimeVal(_0RL_tcdesc, *_sp);
    if (_a.PR_unpackTo(_0RL_tc_Tango_mTimeVal, &_0RL_tcdesc)) {
      ((CORBA::Any *)&_a)->PR_setCachedData((void*)_sp, _0RL_delete_Tango_mTimeVal);
      return 1;
    } else {
      delete (Tango::TimeVal *)_sp; _sp = 0;
      return 0;
    }
  } else {
    CORBA::TypeCode_var _0RL_tctmp = _a.type();
    if (_0RL_tctmp->equivalent(_0RL_tc_Tango_mTimeVal)) return 1;
    _sp = 0;
    return 0;
  }
}
void _0RL_delete_Tango_mDevCmdInfo(void* _data) {
  Tango::DevCmdInfo* _0RL_t = (Tango::DevCmdInfo*) _data;
  delete _0RL_t;
}

static CORBA::Boolean
_0RL_tcParser_getMemberDesc_Tango_mDevCmdInfo(const tcStructDesc *_desc, CORBA::ULong _index, tcDescriptor &_newdesc){
  switch (_index) {
  case 0:
    _0RL_buildDesc_cstring(_newdesc, ((Tango::DevCmdInfo*)_desc->opq_struct)->cmd_name);
    return 1;
  case 1:
    _0RL_buildDesc_clong(_newdesc, ((Tango::DevCmdInfo*)_desc->opq_struct)->cmd_tag);
    return 1;
  case 2:
    _0RL_buildDesc_clong(_newdesc, ((Tango::DevCmdInfo*)_desc->opq_struct)->in_type);
    return 1;
  case 3:
    _0RL_buildDesc_clong(_newdesc, ((Tango::DevCmdInfo*)_desc->opq_struct)->out_type);
    return 1;
  case 4:
    _0RL_buildDesc_cstring(_newdesc, ((Tango::DevCmdInfo*)_desc->opq_struct)->in_type_desc);
    return 1;
  case 5:
    _0RL_buildDesc_cstring(_newdesc, ((Tango::DevCmdInfo*)_desc->opq_struct)->out_type_desc);
    return 1;

  default:
    return 0;
  };
}
static CORBA::ULong

_0RL_tcParser_getMemberCount_Tango_mDevCmdInfo(const tcStructDesc *_desc)
{
  return 6;
}

void _0RL_buildDesc_cTango_mDevCmdInfo(tcDescriptor &_desc, const Tango::DevCmdInfo& _data)
{
  _desc.p_struct.getMemberDesc = _0RL_tcParser_getMemberDesc_Tango_mDevCmdInfo;
  _desc.p_struct.getMemberCount = _0RL_tcParser_getMemberCount_Tango_mDevCmdInfo;
  _desc.p_struct.opq_struct = (void *)&_data;
}



void operator<<=(CORBA::Any& _a, const Tango::DevCmdInfo& _s) {
  tcDescriptor _0RL_tcdesc;
  _0RL_buildDesc_cTango_mDevCmdInfo(_0RL_tcdesc, _s);
  _a.PR_packFrom(_0RL_tc_Tango_mDevCmdInfo, &_0RL_tcdesc);
}
 
void operator<<=(CORBA::Any& _a, Tango::DevCmdInfo* _sp) {
  tcDescriptor _0RL_tcdesc;
  _0RL_buildDesc_cTango_mDevCmdInfo(_0RL_tcdesc, *_sp);
  _a.PR_packFrom(_0RL_tc_Tango_mDevCmdInfo, &_0RL_tcdesc);
  delete _sp;
}

CORBA::Boolean operator>>=(const CORBA::Any& _a, Tango::DevCmdInfo*& _sp) {
  return _a >>= (const Tango::DevCmdInfo*&) _sp;
}

CORBA::Boolean operator>>=(const CORBA::Any& _a, const Tango::DevCmdInfo*& _sp) {
  _sp = (Tango::DevCmdInfo *) _a.PR_getCachedData();
  if (_sp == 0) {
    tcDescriptor _0RL_tcdesc;
    _sp = new Tango::DevCmdInfo;
    _0RL_buildDesc_cTango_mDevCmdInfo(_0RL_tcdesc, *_sp);
    if (_a.PR_unpackTo(_0RL_tc_Tango_mDevCmdInfo, &_0RL_tcdesc)) {
      ((CORBA::Any *)&_a)->PR_setCachedData((void*)_sp, _0RL_delete_Tango_mDevCmdInfo);
      return 1;
    } else {
      delete (Tango::DevCmdInfo *)_sp; _sp = 0;
      return 0;
    }
  } else {
    CORBA::TypeCode_var _0RL_tctmp = _a.type();
    if (_0RL_tctmp->equivalent(_0RL_tc_Tango_mDevCmdInfo)) return 1;
    _sp = 0;
    return 0;
  }
}
void _0RL_delete_Tango_mDevCmdInfo__2(void* _data) {
  Tango::DevCmdInfo_2* _0RL_t = (Tango::DevCmdInfo_2*) _data;
  delete _0RL_t;
}

static CORBA::Boolean
_0RL_tcParser_getMemberDesc_Tango_mDevCmdInfo__2(const tcStructDesc *_desc, CORBA::ULong _index, tcDescriptor &_newdesc){
  switch (_index) {
  case 0:
    _0RL_buildDesc_cstring(_newdesc, ((Tango::DevCmdInfo_2*)_desc->opq_struct)->cmd_name);
    return 1;
  case 1:
    _0RL_buildDesc_cTango_mDispLevel(_newdesc, ((Tango::DevCmdInfo_2*)_desc->opq_struct)->level);
    return 1;
  case 2:
    _0RL_buildDesc_clong(_newdesc, ((Tango::DevCmdInfo_2*)_desc->opq_struct)->cmd_tag);
    return 1;
  case 3:
    _0RL_buildDesc_clong(_newdesc, ((Tango::DevCmdInfo_2*)_desc->opq_struct)->in_type);
    return 1;
  case 4:
    _0RL_buildDesc_clong(_newdesc, ((Tango::DevCmdInfo_2*)_desc->opq_struct)->out_type);
    return 1;
  case 5:
    _0RL_buildDesc_cstring(_newdesc, ((Tango::DevCmdInfo_2*)_desc->opq_struct)->in_type_desc);
    return 1;
  case 6:
    _0RL_buildDesc_cstring(_newdesc, ((Tango::DevCmdInfo_2*)_desc->opq_struct)->out_type_desc);
    return 1;

  default:
    return 0;
  };
}
static CORBA::ULong

_0RL_tcParser_getMemberCount_Tango_mDevCmdInfo__2(const tcStructDesc *_desc)
{
  return 7;
}

void _0RL_buildDesc_cTango_mDevCmdInfo__2(tcDescriptor &_desc, const Tango::DevCmdInfo_2& _data)
{
  _desc.p_struct.getMemberDesc = _0RL_tcParser_getMemberDesc_Tango_mDevCmdInfo__2;
  _desc.p_struct.getMemberCount = _0RL_tcParser_getMemberCount_Tango_mDevCmdInfo__2;
  _desc.p_struct.opq_struct = (void *)&_data;
}



void operator<<=(CORBA::Any& _a, const Tango::DevCmdInfo_2& _s) {
  tcDescriptor _0RL_tcdesc;
  _0RL_buildDesc_cTango_mDevCmdInfo__2(_0RL_tcdesc, _s);
  _a.PR_packFrom(_0RL_tc_Tango_mDevCmdInfo__2, &_0RL_tcdesc);
}
 
void operator<<=(CORBA::Any& _a, Tango::DevCmdInfo_2* _sp) {
  tcDescriptor _0RL_tcdesc;
  _0RL_buildDesc_cTango_mDevCmdInfo__2(_0RL_tcdesc, *_sp);
  _a.PR_packFrom(_0RL_tc_Tango_mDevCmdInfo__2, &_0RL_tcdesc);
  delete _sp;
}

CORBA::Boolean operator>>=(const CORBA::Any& _a, Tango::DevCmdInfo_2*& _sp) {
  return _a >>= (const Tango::DevCmdInfo_2*&) _sp;
}

CORBA::Boolean operator>>=(const CORBA::Any& _a, const Tango::DevCmdInfo_2*& _sp) {
  _sp = (Tango::DevCmdInfo_2 *) _a.PR_getCachedData();
  if (_sp == 0) {
    tcDescriptor _0RL_tcdesc;
    _sp = new Tango::DevCmdInfo_2;
    _0RL_buildDesc_cTango_mDevCmdInfo__2(_0RL_tcdesc, *_sp);
    if (_a.PR_unpackTo(_0RL_tc_Tango_mDevCmdInfo__2, &_0RL_tcdesc)) {
      ((CORBA::Any *)&_a)->PR_setCachedData((void*)_sp, _0RL_delete_Tango_mDevCmdInfo__2);
      return 1;
    } else {
      delete (Tango::DevCmdInfo_2 *)_sp; _sp = 0;
      return 0;
    }
  } else {
    CORBA::TypeCode_var _0RL_tctmp = _a.type();
    if (_0RL_tctmp->equivalent(_0RL_tc_Tango_mDevCmdInfo__2)) return 1;
    _sp = 0;
    return 0;
  }
}
#ifndef __0RL_tcParser_buildDesc_s0_cTango_mDevCmdInfo__
#define __0RL_tcParser_buildDesc_s0_cTango_mDevCmdInfo__
static void
_0RL_tcParser_setElementCount_s0_cTango_mDevCmdInfo(const tcSequenceDesc* _desc, CORBA::ULong _len)
{
  ((_CORBA_Unbounded_Sequence< Tango::DevCmdInfo > *)_desc->opq_seq)->length(_len);
}

static CORBA::ULong
_0RL_tcParser_getElementCount_s0_cTango_mDevCmdInfo(const tcSequenceDesc* _desc)
{
  return ((_CORBA_Unbounded_Sequence< Tango::DevCmdInfo > *)_desc->opq_seq)->length();
}

static CORBA::Boolean
_0RL_tcParser_getElementDesc_s0_cTango_mDevCmdInfo(const tcSequenceDesc* _desc, CORBA::ULong _index, tcDescriptor& _newdesc, _CORBA_ULong& _contiguous)
{
  _0RL_buildDesc_cTango_mDevCmdInfo(_newdesc, (*((_CORBA_Unbounded_Sequence< Tango::DevCmdInfo > *)_desc->opq_seq))[_index]);


  return 1;
}

static void
_0RL_buildDesc_s0_cTango_mDevCmdInfo(tcDescriptor &_desc, const _CORBA_Unbounded_Sequence< Tango::DevCmdInfo > & _data)
{
  _desc.p_sequence.opq_seq = (void*) &_data;
  _desc.p_sequence.setElementCount =
    _0RL_tcParser_setElementCount_s0_cTango_mDevCmdInfo;
  _desc.p_sequence.getElementCount =
    _0RL_tcParser_getElementCount_s0_cTango_mDevCmdInfo;
  _desc.p_sequence.getElementDesc =
    _0RL_tcParser_getElementDesc_s0_cTango_mDevCmdInfo;
  }
#endif

void operator <<= (CORBA::Any& _a, const Tango::DevCmdInfoList& _s)
{
  tcDescriptor tcdesc;
  _0RL_buildDesc_s0_cTango_mDevCmdInfo(tcdesc, _s);
  _a.PR_packFrom(Tango::_tc_DevCmdInfoList, &tcdesc);
}

void _0RL_seq_delete_Tango_mDevCmdInfoList(void* _data)
{
  delete (Tango::DevCmdInfoList*)_data;
}

CORBA::Boolean operator >>= (const CORBA::Any& _a, Tango::DevCmdInfoList*& _s_out)
{
  return _a >>= (const Tango::DevCmdInfoList*&) _s_out;
}

CORBA::Boolean operator >>= (const CORBA::Any& _a, const Tango::DevCmdInfoList*& _s_out)
{
  _s_out = 0;
  Tango::DevCmdInfoList* stmp = (Tango::DevCmdInfoList*) _a.PR_getCachedData();
  if( stmp == 0 ) {
    tcDescriptor tcdesc;
    stmp = new Tango::DevCmdInfoList;
    _0RL_buildDesc_s0_cTango_mDevCmdInfo(tcdesc, *stmp);
    if( _a.PR_unpackTo(Tango::_tc_DevCmdInfoList, &tcdesc)) {
      ((CORBA::Any*)&_a)->PR_setCachedData((void*)stmp, _0RL_seq_delete_Tango_mDevCmdInfoList);
      _s_out = stmp;
      return 1;
    } else {
      delete (Tango::DevCmdInfoList *)stmp;
      return 0;
    }
  } else {
    CORBA::TypeCode_var tctmp = _a.type();
    if( tctmp->equivalent(Tango::_tc_DevCmdInfoList) ) {
      _s_out = stmp;
      return 1;
    } else {
      return 0;
    }
  }
}

#ifndef __0RL_tcParser_buildDesc_s0_cTango_mDevCmdInfo__2__
#define __0RL_tcParser_buildDesc_s0_cTango_mDevCmdInfo__2__
static void
_0RL_tcParser_setElementCount_s0_cTango_mDevCmdInfo__2(const tcSequenceDesc* _desc, CORBA::ULong _len)
{
  ((_CORBA_Unbounded_Sequence< Tango::DevCmdInfo_2 > *)_desc->opq_seq)->length(_len);
}

static CORBA::ULong
_0RL_tcParser_getElementCount_s0_cTango_mDevCmdInfo__2(const tcSequenceDesc* _desc)
{
  return ((_CORBA_Unbounded_Sequence< Tango::DevCmdInfo_2 > *)_desc->opq_seq)->length();
}

static CORBA::Boolean
_0RL_tcParser_getElementDesc_s0_cTango_mDevCmdInfo__2(const tcSequenceDesc* _desc, CORBA::ULong _index, tcDescriptor& _newdesc, _CORBA_ULong& _contiguous)
{
  _0RL_buildDesc_cTango_mDevCmdInfo__2(_newdesc, (*((_CORBA_Unbounded_Sequence< Tango::DevCmdInfo_2 > *)_desc->opq_seq))[_index]);


  return 1;
}

static void
_0RL_buildDesc_s0_cTango_mDevCmdInfo__2(tcDescriptor &_desc, const _CORBA_Unbounded_Sequence< Tango::DevCmdInfo_2 > & _data)
{
  _desc.p_sequence.opq_seq = (void*) &_data;
  _desc.p_sequence.setElementCount =
    _0RL_tcParser_setElementCount_s0_cTango_mDevCmdInfo__2;
  _desc.p_sequence.getElementCount =
    _0RL_tcParser_getElementCount_s0_cTango_mDevCmdInfo__2;
  _desc.p_sequence.getElementDesc =
    _0RL_tcParser_getElementDesc_s0_cTango_mDevCmdInfo__2;
  }
#endif

void operator <<= (CORBA::Any& _a, const Tango::DevCmdInfoList_2& _s)
{
  tcDescriptor tcdesc;
  _0RL_buildDesc_s0_cTango_mDevCmdInfo__2(tcdesc, _s);
  _a.PR_packFrom(Tango::_tc_DevCmdInfoList_2, &tcdesc);
}

void _0RL_seq_delete_Tango_mDevCmdInfoList__2(void* _data)
{
  delete (Tango::DevCmdInfoList_2*)_data;
}

CORBA::Boolean operator >>= (const CORBA::Any& _a, Tango::DevCmdInfoList_2*& _s_out)
{
  return _a >>= (const Tango::DevCmdInfoList_2*&) _s_out;
}

CORBA::Boolean operator >>= (const CORBA::Any& _a, const Tango::DevCmdInfoList_2*& _s_out)
{
  _s_out = 0;
  Tango::DevCmdInfoList_2* stmp = (Tango::DevCmdInfoList_2*) _a.PR_getCachedData();
  if( stmp == 0 ) {
    tcDescriptor tcdesc;
    stmp = new Tango::DevCmdInfoList_2;
    _0RL_buildDesc_s0_cTango_mDevCmdInfo__2(tcdesc, *stmp);
    if( _a.PR_unpackTo(Tango::_tc_DevCmdInfoList_2, &tcdesc)) {
      ((CORBA::Any*)&_a)->PR_setCachedData((void*)stmp, _0RL_seq_delete_Tango_mDevCmdInfoList__2);
      _s_out = stmp;
      return 1;
    } else {
      delete (Tango::DevCmdInfoList_2 *)stmp;
      return 0;
    }
  } else {
    CORBA::TypeCode_var tctmp = _a.type();
    if( tctmp->equivalent(Tango::_tc_DevCmdInfoList_2) ) {
      _s_out = stmp;
      return 1;
    } else {
      return 0;
    }
  }
}

void _0RL_delete_Tango_mDevError(void* _data) {
  Tango::DevError* _0RL_t = (Tango::DevError*) _data;
  delete _0RL_t;
}

static CORBA::Boolean
_0RL_tcParser_getMemberDesc_Tango_mDevError(const tcStructDesc *_desc, CORBA::ULong _index, tcDescriptor &_newdesc){
  switch (_index) {
  case 0:
    _0RL_buildDesc_cstring(_newdesc, ((Tango::DevError*)_desc->opq_struct)->reason);
    return 1;
  case 1:
    _0RL_buildDesc_cTango_mErrSeverity(_newdesc, ((Tango::DevError*)_desc->opq_struct)->severity);
    return 1;
  case 2:
    _0RL_buildDesc_cstring(_newdesc, ((Tango::DevError*)_desc->opq_struct)->desc);
    return 1;
  case 3:
    _0RL_buildDesc_cstring(_newdesc, ((Tango::DevError*)_desc->opq_struct)->origin);
    return 1;

  default:
    return 0;
  };
}
static CORBA::ULong

_0RL_tcParser_getMemberCount_Tango_mDevError(const tcStructDesc *_desc)
{
  return 4;
}

void _0RL_buildDesc_cTango_mDevError(tcDescriptor &_desc, const Tango::DevError& _data)
{
  _desc.p_struct.getMemberDesc = _0RL_tcParser_getMemberDesc_Tango_mDevError;
  _desc.p_struct.getMemberCount = _0RL_tcParser_getMemberCount_Tango_mDevError;
  _desc.p_struct.opq_struct = (void *)&_data;
}



void operator<<=(CORBA::Any& _a, const Tango::DevError& _s) {
  tcDescriptor _0RL_tcdesc;
  _0RL_buildDesc_cTango_mDevError(_0RL_tcdesc, _s);
  _a.PR_packFrom(_0RL_tc_Tango_mDevError, &_0RL_tcdesc);
}
 
void operator<<=(CORBA::Any& _a, Tango::DevError* _sp) {
  tcDescriptor _0RL_tcdesc;
  _0RL_buildDesc_cTango_mDevError(_0RL_tcdesc, *_sp);
  _a.PR_packFrom(_0RL_tc_Tango_mDevError, &_0RL_tcdesc);
  delete _sp;
}

CORBA::Boolean operator>>=(const CORBA::Any& _a, Tango::DevError*& _sp) {
  return _a >>= (const Tango::DevError*&) _sp;
}

CORBA::Boolean operator>>=(const CORBA::Any& _a, const Tango::DevError*& _sp) {
  _sp = (Tango::DevError *) _a.PR_getCachedData();
  if (_sp == 0) {
    tcDescriptor _0RL_tcdesc;
    _sp = new Tango::DevError;
    _0RL_buildDesc_cTango_mDevError(_0RL_tcdesc, *_sp);
    if (_a.PR_unpackTo(_0RL_tc_Tango_mDevError, &_0RL_tcdesc)) {
      ((CORBA::Any *)&_a)->PR_setCachedData((void*)_sp, _0RL_delete_Tango_mDevError);
      return 1;
    } else {
      delete (Tango::DevError *)_sp; _sp = 0;
      return 0;
    }
  } else {
    CORBA::TypeCode_var _0RL_tctmp = _a.type();
    if (_0RL_tctmp->equivalent(_0RL_tc_Tango_mDevError)) return 1;
    _sp = 0;
    return 0;
  }
}
#ifndef __0RL_tcParser_buildDesc_s0_cTango_mDevError__
#define __0RL_tcParser_buildDesc_s0_cTango_mDevError__
static void
_0RL_tcParser_setElementCount_s0_cTango_mDevError(const tcSequenceDesc* _desc, CORBA::ULong _len)
{
  ((_CORBA_Unbounded_Sequence< Tango::DevError > *)_desc->opq_seq)->length(_len);
}

static CORBA::ULong
_0RL_tcParser_getElementCount_s0_cTango_mDevError(const tcSequenceDesc* _desc)
{
  return ((_CORBA_Unbounded_Sequence< Tango::DevError > *)_desc->opq_seq)->length();
}

static CORBA::Boolean
_0RL_tcParser_getElementDesc_s0_cTango_mDevError(const tcSequenceDesc* _desc, CORBA::ULong _index, tcDescriptor& _newdesc, _CORBA_ULong& _contiguous)
{
  _0RL_buildDesc_cTango_mDevError(_newdesc, (*((_CORBA_Unbounded_Sequence< Tango::DevError > *)_desc->opq_seq))[_index]);


  return 1;
}

static void
_0RL_buildDesc_s0_cTango_mDevError(tcDescriptor &_desc, const _CORBA_Unbounded_Sequence< Tango::DevError > & _data)
{
  _desc.p_sequence.opq_seq = (void*) &_data;
  _desc.p_sequence.setElementCount =
    _0RL_tcParser_setElementCount_s0_cTango_mDevError;
  _desc.p_sequence.getElementCount =
    _0RL_tcParser_getElementCount_s0_cTango_mDevError;
  _desc.p_sequence.getElementDesc =
    _0RL_tcParser_getElementDesc_s0_cTango_mDevError;
  }
#endif

void operator <<= (CORBA::Any& _a, const Tango::DevErrorList& _s)
{
  tcDescriptor tcdesc;
  _0RL_buildDesc_s0_cTango_mDevError(tcdesc, _s);
  _a.PR_packFrom(Tango::_tc_DevErrorList, &tcdesc);
}

void _0RL_seq_delete_Tango_mDevErrorList(void* _data)
{
  delete (Tango::DevErrorList*)_data;
}

CORBA::Boolean operator >>= (const CORBA::Any& _a, Tango::DevErrorList*& _s_out)
{
  return _a >>= (const Tango::DevErrorList*&) _s_out;
}

CORBA::Boolean operator >>= (const CORBA::Any& _a, const Tango::DevErrorList*& _s_out)
{
  _s_out = 0;
  Tango::DevErrorList* stmp = (Tango::DevErrorList*) _a.PR_getCachedData();
  if( stmp == 0 ) {
    tcDescriptor tcdesc;
    stmp = new Tango::DevErrorList;
    _0RL_buildDesc_s0_cTango_mDevError(tcdesc, *stmp);
    if( _a.PR_unpackTo(Tango::_tc_DevErrorList, &tcdesc)) {
      ((CORBA::Any*)&_a)->PR_setCachedData((void*)stmp, _0RL_seq_delete_Tango_mDevErrorList);
      _s_out = stmp;
      return 1;
    } else {
      delete (Tango::DevErrorList *)stmp;
      return 0;
    }
  } else {
    CORBA::TypeCode_var tctmp = _a.type();
    if( tctmp->equivalent(Tango::_tc_DevErrorList) ) {
      _s_out = stmp;
      return 1;
    } else {
      return 0;
    }
  }
}

 CORBA::Boolean
_0RL_tcParser_getMemberDesc_Tango_mDevFailed(const tcStructDesc *_desc, CORBA::ULong _index, tcDescriptor &_newdesc){
  switch (_index) {
  case 0:
    _0RL_buildDesc_s0_cTango_mDevError(_newdesc, ((Tango::DevFailed*)_desc->opq_struct)->errors);
    return 1;

  default:
    return 0;
  };
}
 CORBA::ULong

_0RL_tcParser_getMemberCount_Tango_mDevFailed(const tcStructDesc *_desc)
{
  return 1;
}

void _0RL_buildDesc_cTango_mDevFailed(tcDescriptor &_desc, const Tango::DevFailed& _data)
{
  _desc.p_struct.getMemberDesc = _0RL_tcParser_getMemberDesc_Tango_mDevFailed;
  _desc.p_struct.getMemberCount = _0RL_tcParser_getMemberCount_Tango_mDevFailed;
  _desc.p_struct.opq_struct = (void *)&_data;
}

void _0RL_delete_Tango_mDevFailed(void* _data) {
  Tango::DevFailed* _0RL_t = (Tango::DevFailed*) _data;
  delete _0RL_t;
}

void operator<<=(CORBA::Any& _a, const Tango::DevFailed& _s) {
  tcDescriptor _0RL_tcdesc;
  _0RL_buildDesc_cTango_mDevFailed(_0RL_tcdesc, _s);
  _a.PR_packFrom(_0RL_tc_Tango_mDevFailed, &_0RL_tcdesc);
}

void operator<<=(CORBA::Any& _a, const Tango::DevFailed* _sp) {
  tcDescriptor _0RL_tcdesc;
  _0RL_buildDesc_cTango_mDevFailed(_0RL_tcdesc, *_sp);
  _a.PR_packFrom(_0RL_tc_Tango_mDevFailed, &_0RL_tcdesc);
  delete (Tango::DevFailed *)_sp;
}

CORBA::Boolean operator>>=(const CORBA::Any& _a,const Tango::DevFailed*& _sp) {
  _sp = (Tango::DevFailed *) _a.PR_getCachedData();
  if (_sp == 0) {
    tcDescriptor _0RL_tcdesc;
    _sp = new Tango::DevFailed;
    _0RL_buildDesc_cTango_mDevFailed(_0RL_tcdesc, *_sp);
    if (_a.PR_unpackTo(_0RL_tc_Tango_mDevFailed, &_0RL_tcdesc)) {
      ((CORBA::Any *)&_a)->PR_setCachedData((void*)_sp, _0RL_delete_Tango_mDevFailed);
      return 1;
    } else {
      delete (Tango::DevFailed *)_sp;_sp = 0;
      return 0;
    }
  } else {
    CORBA::TypeCode_var _0RL_tctmp = _a.type();
    if (_0RL_tctmp->equivalent(_0RL_tc_Tango_mDevFailed)) return 1;
    delete (Tango::DevFailed *)_sp;_sp = 0;
    return 0;
  }
}

static void _0RL_insertToAny__cTango_mDevFailed(CORBA::Any& _a,const CORBA::Exception& _e) {
  const Tango::DevFailed & _ex = (const Tango::DevFailed &) _e;
  operator<<=(_a,_ex);
}

static void _0RL_insertToAnyNCP__cTango_mDevFailed (CORBA::Any& _a,const CORBA::Exception* _e) {
  const Tango::DevFailed * _ex = (const Tango::DevFailed *) _e;
  operator<<=(_a,_ex);
}

class _0RL_insertToAny_Singleton__cTango_mDevFailed {
public:
  _0RL_insertToAny_Singleton__cTango_mDevFailed() {
    Tango::DevFailed::insertToAnyFn = _0RL_insertToAny__cTango_mDevFailed;
    Tango::DevFailed::insertToAnyFnNCP = _0RL_insertToAnyNCP__cTango_mDevFailed;
  }
};
static _0RL_insertToAny_Singleton__cTango_mDevFailed _0RL_insertToAny_Singleton__cTango_mDevFailed_;

void _0RL_delete_Tango_mAttributeConfig(void* _data) {
  Tango::AttributeConfig* _0RL_t = (Tango::AttributeConfig*) _data;
  delete _0RL_t;
}

static CORBA::Boolean
_0RL_tcParser_getMemberDesc_Tango_mAttributeConfig(const tcStructDesc *_desc, CORBA::ULong _index, tcDescriptor &_newdesc){
  switch (_index) {
  case 0:
    _0RL_buildDesc_cstring(_newdesc, ((Tango::AttributeConfig*)_desc->opq_struct)->name);
    return 1;
  case 1:
    _0RL_buildDesc_cTango_mAttrWriteType(_newdesc, ((Tango::AttributeConfig*)_desc->opq_struct)->writable);
    return 1;
  case 2:
    _0RL_buildDesc_cTango_mAttrDataFormat(_newdesc, ((Tango::AttributeConfig*)_desc->opq_struct)->data_format);
    return 1;
  case 3:
    _0RL_buildDesc_clong(_newdesc, ((Tango::AttributeConfig*)_desc->opq_struct)->data_type);
    return 1;
  case 4:
    _0RL_buildDesc_clong(_newdesc, ((Tango::AttributeConfig*)_desc->opq_struct)->max_dim_x);
    return 1;
  case 5:
    _0RL_buildDesc_clong(_newdesc, ((Tango::AttributeConfig*)_desc->opq_struct)->max_dim_y);
    return 1;
  case 6:
    _0RL_buildDesc_cstring(_newdesc, ((Tango::AttributeConfig*)_desc->opq_struct)->description);
    return 1;
  case 7:
    _0RL_buildDesc_cstring(_newdesc, ((Tango::AttributeConfig*)_desc->opq_struct)->label);
    return 1;
  case 8:
    _0RL_buildDesc_cstring(_newdesc, ((Tango::AttributeConfig*)_desc->opq_struct)->unit);
    return 1;
  case 9:
    _0RL_buildDesc_cstring(_newdesc, ((Tango::AttributeConfig*)_desc->opq_struct)->standard_unit);
    return 1;
  case 10:
    _0RL_buildDesc_cstring(_newdesc, ((Tango::AttributeConfig*)_desc->opq_struct)->display_unit);
    return 1;
  case 11:
    _0RL_buildDesc_cstring(_newdesc, ((Tango::AttributeConfig*)_desc->opq_struct)->format);
    return 1;
  case 12:
    _0RL_buildDesc_cstring(_newdesc, ((Tango::AttributeConfig*)_desc->opq_struct)->min_value);
    return 1;
  case 13:
    _0RL_buildDesc_cstring(_newdesc, ((Tango::AttributeConfig*)_desc->opq_struct)->max_value);
    return 1;
  case 14:
    _0RL_buildDesc_cstring(_newdesc, ((Tango::AttributeConfig*)_desc->opq_struct)->min_alarm);
    return 1;
  case 15:
    _0RL_buildDesc_cstring(_newdesc, ((Tango::AttributeConfig*)_desc->opq_struct)->max_alarm);
    return 1;
  case 16:
    _0RL_buildDesc_cstring(_newdesc, ((Tango::AttributeConfig*)_desc->opq_struct)->writable_attr_name);
    return 1;
  case 17:
    _0RL_buildDesc_s0_cstring(_newdesc, ((Tango::AttributeConfig*)_desc->opq_struct)->extensions);
    return 1;

  default:
    return 0;
  };
}
static CORBA::ULong

_0RL_tcParser_getMemberCount_Tango_mAttributeConfig(const tcStructDesc *_desc)
{
  return 18;
}

void _0RL_buildDesc_cTango_mAttributeConfig(tcDescriptor &_desc, const Tango::AttributeConfig& _data)
{
  _desc.p_struct.getMemberDesc = _0RL_tcParser_getMemberDesc_Tango_mAttributeConfig;
  _desc.p_struct.getMemberCount = _0RL_tcParser_getMemberCount_Tango_mAttributeConfig;
  _desc.p_struct.opq_struct = (void *)&_data;
}



void operator<<=(CORBA::Any& _a, const Tango::AttributeConfig& _s) {
  tcDescriptor _0RL_tcdesc;
  _0RL_buildDesc_cTango_mAttributeConfig(_0RL_tcdesc, _s);
  _a.PR_packFrom(_0RL_tc_Tango_mAttributeConfig, &_0RL_tcdesc);
}
 
void operator<<=(CORBA::Any& _a, Tango::AttributeConfig* _sp) {
  tcDescriptor _0RL_tcdesc;
  _0RL_buildDesc_cTango_mAttributeConfig(_0RL_tcdesc, *_sp);
  _a.PR_packFrom(_0RL_tc_Tango_mAttributeConfig, &_0RL_tcdesc);
  delete _sp;
}

CORBA::Boolean operator>>=(const CORBA::Any& _a, Tango::AttributeConfig*& _sp) {
  return _a >>= (const Tango::AttributeConfig*&) _sp;
}

CORBA::Boolean operator>>=(const CORBA::Any& _a, const Tango::AttributeConfig*& _sp) {
  _sp = (Tango::AttributeConfig *) _a.PR_getCachedData();
  if (_sp == 0) {
    tcDescriptor _0RL_tcdesc;
    _sp = new Tango::AttributeConfig;
    _0RL_buildDesc_cTango_mAttributeConfig(_0RL_tcdesc, *_sp);
    if (_a.PR_unpackTo(_0RL_tc_Tango_mAttributeConfig, &_0RL_tcdesc)) {
      ((CORBA::Any *)&_a)->PR_setCachedData((void*)_sp, _0RL_delete_Tango_mAttributeConfig);
      return 1;
    } else {
      delete (Tango::AttributeConfig *)_sp; _sp = 0;
      return 0;
    }
  } else {
    CORBA::TypeCode_var _0RL_tctmp = _a.type();
    if (_0RL_tctmp->equivalent(_0RL_tc_Tango_mAttributeConfig)) return 1;
    _sp = 0;
    return 0;
  }
}
void _0RL_delete_Tango_mAttributeConfig__2(void* _data) {
  Tango::AttributeConfig_2* _0RL_t = (Tango::AttributeConfig_2*) _data;
  delete _0RL_t;
}

static CORBA::Boolean
_0RL_tcParser_getMemberDesc_Tango_mAttributeConfig__2(const tcStructDesc *_desc, CORBA::ULong _index, tcDescriptor &_newdesc){
  switch (_index) {
  case 0:
    _0RL_buildDesc_cstring(_newdesc, ((Tango::AttributeConfig_2*)_desc->opq_struct)->name);
    return 1;
  case 1:
    _0RL_buildDesc_cTango_mAttrWriteType(_newdesc, ((Tango::AttributeConfig_2*)_desc->opq_struct)->writable);
    return 1;
  case 2:
    _0RL_buildDesc_cTango_mAttrDataFormat(_newdesc, ((Tango::AttributeConfig_2*)_desc->opq_struct)->data_format);
    return 1;
  case 3:
    _0RL_buildDesc_clong(_newdesc, ((Tango::AttributeConfig_2*)_desc->opq_struct)->data_type);
    return 1;
  case 4:
    _0RL_buildDesc_clong(_newdesc, ((Tango::AttributeConfig_2*)_desc->opq_struct)->max_dim_x);
    return 1;
  case 5:
    _0RL_buildDesc_clong(_newdesc, ((Tango::AttributeConfig_2*)_desc->opq_struct)->max_dim_y);
    return 1;
  case 6:
    _0RL_buildDesc_cstring(_newdesc, ((Tango::AttributeConfig_2*)_desc->opq_struct)->description);
    return 1;
  case 7:
    _0RL_buildDesc_cstring(_newdesc, ((Tango::AttributeConfig_2*)_desc->opq_struct)->label);
    return 1;
  case 8:
    _0RL_buildDesc_cstring(_newdesc, ((Tango::AttributeConfig_2*)_desc->opq_struct)->unit);
    return 1;
  case 9:
    _0RL_buildDesc_cstring(_newdesc, ((Tango::AttributeConfig_2*)_desc->opq_struct)->standard_unit);
    return 1;
  case 10:
    _0RL_buildDesc_cstring(_newdesc, ((Tango::AttributeConfig_2*)_desc->opq_struct)->display_unit);
    return 1;
  case 11:
    _0RL_buildDesc_cstring(_newdesc, ((Tango::AttributeConfig_2*)_desc->opq_struct)->format);
    return 1;
  case 12:
    _0RL_buildDesc_cstring(_newdesc, ((Tango::AttributeConfig_2*)_desc->opq_struct)->min_value);
    return 1;
  case 13:
    _0RL_buildDesc_cstring(_newdesc, ((Tango::AttributeConfig_2*)_desc->opq_struct)->max_value);
    return 1;
  case 14:
    _0RL_buildDesc_cstring(_newdesc, ((Tango::AttributeConfig_2*)_desc->opq_struct)->min_alarm);
    return 1;
  case 15:
    _0RL_buildDesc_cstring(_newdesc, ((Tango::AttributeConfig_2*)_desc->opq_struct)->max_alarm);
    return 1;
  case 16:
    _0RL_buildDesc_cstring(_newdesc, ((Tango::AttributeConfig_2*)_desc->opq_struct)->writable_attr_name);
    return 1;
  case 17:
    _0RL_buildDesc_cTango_mDispLevel(_newdesc, ((Tango::AttributeConfig_2*)_desc->opq_struct)->level);
    return 1;
  case 18:
    _0RL_buildDesc_s0_cstring(_newdesc, ((Tango::AttributeConfig_2*)_desc->opq_struct)->extensions);
    return 1;

  default:
    return 0;
  };
}
static CORBA::ULong

_0RL_tcParser_getMemberCount_Tango_mAttributeConfig__2(const tcStructDesc *_desc)
{
  return 19;
}

void _0RL_buildDesc_cTango_mAttributeConfig__2(tcDescriptor &_desc, const Tango::AttributeConfig_2& _data)
{
  _desc.p_struct.getMemberDesc = _0RL_tcParser_getMemberDesc_Tango_mAttributeConfig__2;
  _desc.p_struct.getMemberCount = _0RL_tcParser_getMemberCount_Tango_mAttributeConfig__2;
  _desc.p_struct.opq_struct = (void *)&_data;
}



void operator<<=(CORBA::Any& _a, const Tango::AttributeConfig_2& _s) {
  tcDescriptor _0RL_tcdesc;
  _0RL_buildDesc_cTango_mAttributeConfig__2(_0RL_tcdesc, _s);
  _a.PR_packFrom(_0RL_tc_Tango_mAttributeConfig__2, &_0RL_tcdesc);
}
 
void operator<<=(CORBA::Any& _a, Tango::AttributeConfig_2* _sp) {
  tcDescriptor _0RL_tcdesc;
  _0RL_buildDesc_cTango_mAttributeConfig__2(_0RL_tcdesc, *_sp);
  _a.PR_packFrom(_0RL_tc_Tango_mAttributeConfig__2, &_0RL_tcdesc);
  delete _sp;
}

CORBA::Boolean operator>>=(const CORBA::Any& _a, Tango::AttributeConfig_2*& _sp) {
  return _a >>= (const Tango::AttributeConfig_2*&) _sp;
}

CORBA::Boolean operator>>=(const CORBA::Any& _a, const Tango::AttributeConfig_2*& _sp) {
  _sp = (Tango::AttributeConfig_2 *) _a.PR_getCachedData();
  if (_sp == 0) {
    tcDescriptor _0RL_tcdesc;
    _sp = new Tango::AttributeConfig_2;
    _0RL_buildDesc_cTango_mAttributeConfig__2(_0RL_tcdesc, *_sp);
    if (_a.PR_unpackTo(_0RL_tc_Tango_mAttributeConfig__2, &_0RL_tcdesc)) {
      ((CORBA::Any *)&_a)->PR_setCachedData((void*)_sp, _0RL_delete_Tango_mAttributeConfig__2);
      return 1;
    } else {
      delete (Tango::AttributeConfig_2 *)_sp; _sp = 0;
      return 0;
    }
  } else {
    CORBA::TypeCode_var _0RL_tctmp = _a.type();
    if (_0RL_tctmp->equivalent(_0RL_tc_Tango_mAttributeConfig__2)) return 1;
    _sp = 0;
    return 0;
  }
}
void _0RL_delete_Tango_mAttributeValue(void* _data) {
  Tango::AttributeValue* _0RL_t = (Tango::AttributeValue*) _data;
  delete _0RL_t;
}

static CORBA::Boolean
_0RL_tcParser_getMemberDesc_Tango_mAttributeValue(const tcStructDesc *_desc, CORBA::ULong _index, tcDescriptor &_newdesc){
  switch (_index) {
  case 0:
    _0RL_buildDesc_cany(_newdesc, ((Tango::AttributeValue*)_desc->opq_struct)->value);
    return 1;
  case 1:
    _0RL_buildDesc_cTango_mAttrQuality(_newdesc, ((Tango::AttributeValue*)_desc->opq_struct)->quality);
    return 1;
  case 2:
    _0RL_buildDesc_cTango_mTimeVal(_newdesc, ((Tango::AttributeValue*)_desc->opq_struct)->time);
    return 1;
  case 3:
    _0RL_buildDesc_cstring(_newdesc, ((Tango::AttributeValue*)_desc->opq_struct)->name);
    return 1;
  case 4:
    _0RL_buildDesc_clong(_newdesc, ((Tango::AttributeValue*)_desc->opq_struct)->dim_x);
    return 1;
  case 5:
    _0RL_buildDesc_clong(_newdesc, ((Tango::AttributeValue*)_desc->opq_struct)->dim_y);
    return 1;

  default:
    return 0;
  };
}
static CORBA::ULong

_0RL_tcParser_getMemberCount_Tango_mAttributeValue(const tcStructDesc *_desc)
{
  return 6;
}

void _0RL_buildDesc_cTango_mAttributeValue(tcDescriptor &_desc, const Tango::AttributeValue& _data)
{
  _desc.p_struct.getMemberDesc = _0RL_tcParser_getMemberDesc_Tango_mAttributeValue;
  _desc.p_struct.getMemberCount = _0RL_tcParser_getMemberCount_Tango_mAttributeValue;
  _desc.p_struct.opq_struct = (void *)&_data;
}



void operator<<=(CORBA::Any& _a, const Tango::AttributeValue& _s) {
  tcDescriptor _0RL_tcdesc;
  _0RL_buildDesc_cTango_mAttributeValue(_0RL_tcdesc, _s);
  _a.PR_packFrom(_0RL_tc_Tango_mAttributeValue, &_0RL_tcdesc);
}
 
void operator<<=(CORBA::Any& _a, Tango::AttributeValue* _sp) {
  tcDescriptor _0RL_tcdesc;
  _0RL_buildDesc_cTango_mAttributeValue(_0RL_tcdesc, *_sp);
  _a.PR_packFrom(_0RL_tc_Tango_mAttributeValue, &_0RL_tcdesc);
  delete _sp;
}

CORBA::Boolean operator>>=(const CORBA::Any& _a, Tango::AttributeValue*& _sp) {
  return _a >>= (const Tango::AttributeValue*&) _sp;
}

CORBA::Boolean operator>>=(const CORBA::Any& _a, const Tango::AttributeValue*& _sp) {
  _sp = (Tango::AttributeValue *) _a.PR_getCachedData();
  if (_sp == 0) {
    tcDescriptor _0RL_tcdesc;
    _sp = new Tango::AttributeValue;
    _0RL_buildDesc_cTango_mAttributeValue(_0RL_tcdesc, *_sp);
    if (_a.PR_unpackTo(_0RL_tc_Tango_mAttributeValue, &_0RL_tcdesc)) {
      ((CORBA::Any *)&_a)->PR_setCachedData((void*)_sp, _0RL_delete_Tango_mAttributeValue);
      return 1;
    } else {
      delete (Tango::AttributeValue *)_sp; _sp = 0;
      return 0;
    }
  } else {
    CORBA::TypeCode_var _0RL_tctmp = _a.type();
    if (_0RL_tctmp->equivalent(_0RL_tc_Tango_mAttributeValue)) return 1;
    _sp = 0;
    return 0;
  }
}
#ifndef __0RL_tcParser_buildDesc_s0_cTango_mAttributeConfig__
#define __0RL_tcParser_buildDesc_s0_cTango_mAttributeConfig__
static void
_0RL_tcParser_setElementCount_s0_cTango_mAttributeConfig(const tcSequenceDesc* _desc, CORBA::ULong _len)
{
  ((_CORBA_Unbounded_Sequence< Tango::AttributeConfig > *)_desc->opq_seq)->length(_len);
}

static CORBA::ULong
_0RL_tcParser_getElementCount_s0_cTango_mAttributeConfig(const tcSequenceDesc* _desc)
{
  return ((_CORBA_Unbounded_Sequence< Tango::AttributeConfig > *)_desc->opq_seq)->length();
}

static CORBA::Boolean
_0RL_tcParser_getElementDesc_s0_cTango_mAttributeConfig(const tcSequenceDesc* _desc, CORBA::ULong _index, tcDescriptor& _newdesc, _CORBA_ULong& _contiguous)
{
  _0RL_buildDesc_cTango_mAttributeConfig(_newdesc, (*((_CORBA_Unbounded_Sequence< Tango::AttributeConfig > *)_desc->opq_seq))[_index]);


  return 1;
}

static void
_0RL_buildDesc_s0_cTango_mAttributeConfig(tcDescriptor &_desc, const _CORBA_Unbounded_Sequence< Tango::AttributeConfig > & _data)
{
  _desc.p_sequence.opq_seq = (void*) &_data;
  _desc.p_sequence.setElementCount =
    _0RL_tcParser_setElementCount_s0_cTango_mAttributeConfig;
  _desc.p_sequence.getElementCount =
    _0RL_tcParser_getElementCount_s0_cTango_mAttributeConfig;
  _desc.p_sequence.getElementDesc =
    _0RL_tcParser_getElementDesc_s0_cTango_mAttributeConfig;
  }
#endif

void operator <<= (CORBA::Any& _a, const Tango::AttributeConfigList& _s)
{
  tcDescriptor tcdesc;
  _0RL_buildDesc_s0_cTango_mAttributeConfig(tcdesc, _s);
  _a.PR_packFrom(Tango::_tc_AttributeConfigList, &tcdesc);
}

void _0RL_seq_delete_Tango_mAttributeConfigList(void* _data)
{
  delete (Tango::AttributeConfigList*)_data;
}

CORBA::Boolean operator >>= (const CORBA::Any& _a, Tango::AttributeConfigList*& _s_out)
{
  return _a >>= (const Tango::AttributeConfigList*&) _s_out;
}

CORBA::Boolean operator >>= (const CORBA::Any& _a, const Tango::AttributeConfigList*& _s_out)
{
  _s_out = 0;
  Tango::AttributeConfigList* stmp = (Tango::AttributeConfigList*) _a.PR_getCachedData();
  if( stmp == 0 ) {
    tcDescriptor tcdesc;
    stmp = new Tango::AttributeConfigList;
    _0RL_buildDesc_s0_cTango_mAttributeConfig(tcdesc, *stmp);
    if( _a.PR_unpackTo(Tango::_tc_AttributeConfigList, &tcdesc)) {
      ((CORBA::Any*)&_a)->PR_setCachedData((void*)stmp, _0RL_seq_delete_Tango_mAttributeConfigList);
      _s_out = stmp;
      return 1;
    } else {
      delete (Tango::AttributeConfigList *)stmp;
      return 0;
    }
  } else {
    CORBA::TypeCode_var tctmp = _a.type();
    if( tctmp->equivalent(Tango::_tc_AttributeConfigList) ) {
      _s_out = stmp;
      return 1;
    } else {
      return 0;
    }
  }
}

#ifndef __0RL_tcParser_buildDesc_s0_cTango_mAttributeConfig__2__
#define __0RL_tcParser_buildDesc_s0_cTango_mAttributeConfig__2__
static void
_0RL_tcParser_setElementCount_s0_cTango_mAttributeConfig__2(const tcSequenceDesc* _desc, CORBA::ULong _len)
{
  ((_CORBA_Unbounded_Sequence< Tango::AttributeConfig_2 > *)_desc->opq_seq)->length(_len);
}

static CORBA::ULong
_0RL_tcParser_getElementCount_s0_cTango_mAttributeConfig__2(const tcSequenceDesc* _desc)
{
  return ((_CORBA_Unbounded_Sequence< Tango::AttributeConfig_2 > *)_desc->opq_seq)->length();
}

static CORBA::Boolean
_0RL_tcParser_getElementDesc_s0_cTango_mAttributeConfig__2(const tcSequenceDesc* _desc, CORBA::ULong _index, tcDescriptor& _newdesc, _CORBA_ULong& _contiguous)
{
  _0RL_buildDesc_cTango_mAttributeConfig__2(_newdesc, (*((_CORBA_Unbounded_Sequence< Tango::AttributeConfig_2 > *)_desc->opq_seq))[_index]);


  return 1;
}

static void
_0RL_buildDesc_s0_cTango_mAttributeConfig__2(tcDescriptor &_desc, const _CORBA_Unbounded_Sequence< Tango::AttributeConfig_2 > & _data)
{
  _desc.p_sequence.opq_seq = (void*) &_data;
  _desc.p_sequence.setElementCount =
    _0RL_tcParser_setElementCount_s0_cTango_mAttributeConfig__2;
  _desc.p_sequence.getElementCount =
    _0RL_tcParser_getElementCount_s0_cTango_mAttributeConfig__2;
  _desc.p_sequence.getElementDesc =
    _0RL_tcParser_getElementDesc_s0_cTango_mAttributeConfig__2;
  }
#endif

void operator <<= (CORBA::Any& _a, const Tango::AttributeConfigList_2& _s)
{
  tcDescriptor tcdesc;
  _0RL_buildDesc_s0_cTango_mAttributeConfig__2(tcdesc, _s);
  _a.PR_packFrom(Tango::_tc_AttributeConfigList_2, &tcdesc);
}

void _0RL_seq_delete_Tango_mAttributeConfigList__2(void* _data)
{
  delete (Tango::AttributeConfigList_2*)_data;
}

CORBA::Boolean operator >>= (const CORBA::Any& _a, Tango::AttributeConfigList_2*& _s_out)
{
  return _a >>= (const Tango::AttributeConfigList_2*&) _s_out;
}

CORBA::Boolean operator >>= (const CORBA::Any& _a, const Tango::AttributeConfigList_2*& _s_out)
{
  _s_out = 0;
  Tango::AttributeConfigList_2* stmp = (Tango::AttributeConfigList_2*) _a.PR_getCachedData();
  if( stmp == 0 ) {
    tcDescriptor tcdesc;
    stmp = new Tango::AttributeConfigList_2;
    _0RL_buildDesc_s0_cTango_mAttributeConfig__2(tcdesc, *stmp);
    if( _a.PR_unpackTo(Tango::_tc_AttributeConfigList_2, &tcdesc)) {
      ((CORBA::Any*)&_a)->PR_setCachedData((void*)stmp, _0RL_seq_delete_Tango_mAttributeConfigList__2);
      _s_out = stmp;
      return 1;
    } else {
      delete (Tango::AttributeConfigList_2 *)stmp;
      return 0;
    }
  } else {
    CORBA::TypeCode_var tctmp = _a.type();
    if( tctmp->equivalent(Tango::_tc_AttributeConfigList_2) ) {
      _s_out = stmp;
      return 1;
    } else {
      return 0;
    }
  }
}

#ifndef __0RL_tcParser_buildDesc_s0_cTango_mAttributeValue__
#define __0RL_tcParser_buildDesc_s0_cTango_mAttributeValue__
static void
_0RL_tcParser_setElementCount_s0_cTango_mAttributeValue(const tcSequenceDesc* _desc, CORBA::ULong _len)
{
  ((_CORBA_Unbounded_Sequence< Tango::AttributeValue > *)_desc->opq_seq)->length(_len);
}

static CORBA::ULong
_0RL_tcParser_getElementCount_s0_cTango_mAttributeValue(const tcSequenceDesc* _desc)
{
  return ((_CORBA_Unbounded_Sequence< Tango::AttributeValue > *)_desc->opq_seq)->length();
}

static CORBA::Boolean
_0RL_tcParser_getElementDesc_s0_cTango_mAttributeValue(const tcSequenceDesc* _desc, CORBA::ULong _index, tcDescriptor& _newdesc, _CORBA_ULong& _contiguous)
{
  _0RL_buildDesc_cTango_mAttributeValue(_newdesc, (*((_CORBA_Unbounded_Sequence< Tango::AttributeValue > *)_desc->opq_seq))[_index]);


  return 1;
}

static void
_0RL_buildDesc_s0_cTango_mAttributeValue(tcDescriptor &_desc, const _CORBA_Unbounded_Sequence< Tango::AttributeValue > & _data)
{
  _desc.p_sequence.opq_seq = (void*) &_data;
  _desc.p_sequence.setElementCount =
    _0RL_tcParser_setElementCount_s0_cTango_mAttributeValue;
  _desc.p_sequence.getElementCount =
    _0RL_tcParser_getElementCount_s0_cTango_mAttributeValue;
  _desc.p_sequence.getElementDesc =
    _0RL_tcParser_getElementDesc_s0_cTango_mAttributeValue;
  }
#endif

void operator <<= (CORBA::Any& _a, const Tango::AttributeValueList& _s)
{
  tcDescriptor tcdesc;
  _0RL_buildDesc_s0_cTango_mAttributeValue(tcdesc, _s);
  _a.PR_packFrom(Tango::_tc_AttributeValueList, &tcdesc);
}

void _0RL_seq_delete_Tango_mAttributeValueList(void* _data)
{
  delete (Tango::AttributeValueList*)_data;
}

CORBA::Boolean operator >>= (const CORBA::Any& _a, Tango::AttributeValueList*& _s_out)
{
  return _a >>= (const Tango::AttributeValueList*&) _s_out;
}

CORBA::Boolean operator >>= (const CORBA::Any& _a, const Tango::AttributeValueList*& _s_out)
{
  _s_out = 0;
  Tango::AttributeValueList* stmp = (Tango::AttributeValueList*) _a.PR_getCachedData();
  if( stmp == 0 ) {
    tcDescriptor tcdesc;
    stmp = new Tango::AttributeValueList;
    _0RL_buildDesc_s0_cTango_mAttributeValue(tcdesc, *stmp);
    if( _a.PR_unpackTo(Tango::_tc_AttributeValueList, &tcdesc)) {
      ((CORBA::Any*)&_a)->PR_setCachedData((void*)stmp, _0RL_seq_delete_Tango_mAttributeValueList);
      _s_out = stmp;
      return 1;
    } else {
      delete (Tango::AttributeValueList *)stmp;
      return 0;
    }
  } else {
    CORBA::TypeCode_var tctmp = _a.type();
    if( tctmp->equivalent(Tango::_tc_AttributeValueList) ) {
      _s_out = stmp;
      return 1;
    } else {
      return 0;
    }
  }
}

void _0RL_delete_Tango_mDevInfo(void* _data) {
  Tango::DevInfo* _0RL_t = (Tango::DevInfo*) _data;
  delete _0RL_t;
}

static CORBA::Boolean
_0RL_tcParser_getMemberDesc_Tango_mDevInfo(const tcStructDesc *_desc, CORBA::ULong _index, tcDescriptor &_newdesc){
  switch (_index) {
  case 0:
    _0RL_buildDesc_cstring(_newdesc, ((Tango::DevInfo*)_desc->opq_struct)->dev_class);
    return 1;
  case 1:
    _0RL_buildDesc_cstring(_newdesc, ((Tango::DevInfo*)_desc->opq_struct)->server_id);
    return 1;
  case 2:
    _0RL_buildDesc_cstring(_newdesc, ((Tango::DevInfo*)_desc->opq_struct)->server_host);
    return 1;
  case 3:
    _0RL_buildDesc_clong(_newdesc, ((Tango::DevInfo*)_desc->opq_struct)->server_version);
    return 1;
  case 4:
    _0RL_buildDesc_cstring(_newdesc, ((Tango::DevInfo*)_desc->opq_struct)->doc_url);
    return 1;

  default:
    return 0;
  };
}
static CORBA::ULong

_0RL_tcParser_getMemberCount_Tango_mDevInfo(const tcStructDesc *_desc)
{
  return 5;
}

void _0RL_buildDesc_cTango_mDevInfo(tcDescriptor &_desc, const Tango::DevInfo& _data)
{
  _desc.p_struct.getMemberDesc = _0RL_tcParser_getMemberDesc_Tango_mDevInfo;
  _desc.p_struct.getMemberCount = _0RL_tcParser_getMemberCount_Tango_mDevInfo;
  _desc.p_struct.opq_struct = (void *)&_data;
}



void operator<<=(CORBA::Any& _a, const Tango::DevInfo& _s) {
  tcDescriptor _0RL_tcdesc;
  _0RL_buildDesc_cTango_mDevInfo(_0RL_tcdesc, _s);
  _a.PR_packFrom(_0RL_tc_Tango_mDevInfo, &_0RL_tcdesc);
}
 
void operator<<=(CORBA::Any& _a, Tango::DevInfo* _sp) {
  tcDescriptor _0RL_tcdesc;
  _0RL_buildDesc_cTango_mDevInfo(_0RL_tcdesc, *_sp);
  _a.PR_packFrom(_0RL_tc_Tango_mDevInfo, &_0RL_tcdesc);
  delete _sp;
}

CORBA::Boolean operator>>=(const CORBA::Any& _a, Tango::DevInfo*& _sp) {
  return _a >>= (const Tango::DevInfo*&) _sp;
}

CORBA::Boolean operator>>=(const CORBA::Any& _a, const Tango::DevInfo*& _sp) {
  _sp = (Tango::DevInfo *) _a.PR_getCachedData();
  if (_sp == 0) {
    tcDescriptor _0RL_tcdesc;
    _sp = new Tango::DevInfo;
    _0RL_buildDesc_cTango_mDevInfo(_0RL_tcdesc, *_sp);
    if (_a.PR_unpackTo(_0RL_tc_Tango_mDevInfo, &_0RL_tcdesc)) {
      ((CORBA::Any *)&_a)->PR_setCachedData((void*)_sp, _0RL_delete_Tango_mDevInfo);
      return 1;
    } else {
      delete (Tango::DevInfo *)_sp; _sp = 0;
      return 0;
    }
  } else {
    CORBA::TypeCode_var _0RL_tctmp = _a.type();
    if (_0RL_tctmp->equivalent(_0RL_tc_Tango_mDevInfo)) return 1;
    _sp = 0;
    return 0;
  }
}
void _0RL_delete_Tango_mDevCmdHistory(void* _data) {
  Tango::DevCmdHistory* _0RL_t = (Tango::DevCmdHistory*) _data;
  delete _0RL_t;
}

static CORBA::Boolean
_0RL_tcParser_getMemberDesc_Tango_mDevCmdHistory(const tcStructDesc *_desc, CORBA::ULong _index, tcDescriptor &_newdesc){
  switch (_index) {
  case 0:
    _0RL_buildDesc_cTango_mTimeVal(_newdesc, ((Tango::DevCmdHistory*)_desc->opq_struct)->time);
    return 1;
  case 1:
    _0RL_buildDesc_cboolean(_newdesc, ((Tango::DevCmdHistory*)_desc->opq_struct)->cmd_failed);
    return 1;
  case 2:
    _0RL_buildDesc_cany(_newdesc, ((Tango::DevCmdHistory*)_desc->opq_struct)->value);
    return 1;
  case 3:
    _0RL_buildDesc_s0_cTango_mDevError(_newdesc, ((Tango::DevCmdHistory*)_desc->opq_struct)->errors);
    return 1;

  default:
    return 0;
  };
}
static CORBA::ULong

_0RL_tcParser_getMemberCount_Tango_mDevCmdHistory(const tcStructDesc *_desc)
{
  return 4;
}

void _0RL_buildDesc_cTango_mDevCmdHistory(tcDescriptor &_desc, const Tango::DevCmdHistory& _data)
{
  _desc.p_struct.getMemberDesc = _0RL_tcParser_getMemberDesc_Tango_mDevCmdHistory;
  _desc.p_struct.getMemberCount = _0RL_tcParser_getMemberCount_Tango_mDevCmdHistory;
  _desc.p_struct.opq_struct = (void *)&_data;
}



void operator<<=(CORBA::Any& _a, const Tango::DevCmdHistory& _s) {
  tcDescriptor _0RL_tcdesc;
  _0RL_buildDesc_cTango_mDevCmdHistory(_0RL_tcdesc, _s);
  _a.PR_packFrom(_0RL_tc_Tango_mDevCmdHistory, &_0RL_tcdesc);
}
 
void operator<<=(CORBA::Any& _a, Tango::DevCmdHistory* _sp) {
  tcDescriptor _0RL_tcdesc;
  _0RL_buildDesc_cTango_mDevCmdHistory(_0RL_tcdesc, *_sp);
  _a.PR_packFrom(_0RL_tc_Tango_mDevCmdHistory, &_0RL_tcdesc);
  delete _sp;
}

CORBA::Boolean operator>>=(const CORBA::Any& _a, Tango::DevCmdHistory*& _sp) {
  return _a >>= (const Tango::DevCmdHistory*&) _sp;
}

CORBA::Boolean operator>>=(const CORBA::Any& _a, const Tango::DevCmdHistory*& _sp) {
  _sp = (Tango::DevCmdHistory *) _a.PR_getCachedData();
  if (_sp == 0) {
    tcDescriptor _0RL_tcdesc;
    _sp = new Tango::DevCmdHistory;
    _0RL_buildDesc_cTango_mDevCmdHistory(_0RL_tcdesc, *_sp);
    if (_a.PR_unpackTo(_0RL_tc_Tango_mDevCmdHistory, &_0RL_tcdesc)) {
      ((CORBA::Any *)&_a)->PR_setCachedData((void*)_sp, _0RL_delete_Tango_mDevCmdHistory);
      return 1;
    } else {
      delete (Tango::DevCmdHistory *)_sp; _sp = 0;
      return 0;
    }
  } else {
    CORBA::TypeCode_var _0RL_tctmp = _a.type();
    if (_0RL_tctmp->equivalent(_0RL_tc_Tango_mDevCmdHistory)) return 1;
    _sp = 0;
    return 0;
  }
}
#ifndef __0RL_tcParser_buildDesc_s0_cTango_mDevCmdHistory__
#define __0RL_tcParser_buildDesc_s0_cTango_mDevCmdHistory__
static void
_0RL_tcParser_setElementCount_s0_cTango_mDevCmdHistory(const tcSequenceDesc* _desc, CORBA::ULong _len)
{
  ((_CORBA_Unbounded_Sequence< Tango::DevCmdHistory > *)_desc->opq_seq)->length(_len);
}

static CORBA::ULong
_0RL_tcParser_getElementCount_s0_cTango_mDevCmdHistory(const tcSequenceDesc* _desc)
{
  return ((_CORBA_Unbounded_Sequence< Tango::DevCmdHistory > *)_desc->opq_seq)->length();
}

static CORBA::Boolean
_0RL_tcParser_getElementDesc_s0_cTango_mDevCmdHistory(const tcSequenceDesc* _desc, CORBA::ULong _index, tcDescriptor& _newdesc, _CORBA_ULong& _contiguous)
{
  _0RL_buildDesc_cTango_mDevCmdHistory(_newdesc, (*((_CORBA_Unbounded_Sequence< Tango::DevCmdHistory > *)_desc->opq_seq))[_index]);


  return 1;
}

static void
_0RL_buildDesc_s0_cTango_mDevCmdHistory(tcDescriptor &_desc, const _CORBA_Unbounded_Sequence< Tango::DevCmdHistory > & _data)
{
  _desc.p_sequence.opq_seq = (void*) &_data;
  _desc.p_sequence.setElementCount =
    _0RL_tcParser_setElementCount_s0_cTango_mDevCmdHistory;
  _desc.p_sequence.getElementCount =
    _0RL_tcParser_getElementCount_s0_cTango_mDevCmdHistory;
  _desc.p_sequence.getElementDesc =
    _0RL_tcParser_getElementDesc_s0_cTango_mDevCmdHistory;
  }
#endif

void operator <<= (CORBA::Any& _a, const Tango::DevCmdHistoryList& _s)
{
  tcDescriptor tcdesc;
  _0RL_buildDesc_s0_cTango_mDevCmdHistory(tcdesc, _s);
  _a.PR_packFrom(Tango::_tc_DevCmdHistoryList, &tcdesc);
}

void _0RL_seq_delete_Tango_mDevCmdHistoryList(void* _data)
{
  delete (Tango::DevCmdHistoryList*)_data;
}

CORBA::Boolean operator >>= (const CORBA::Any& _a, Tango::DevCmdHistoryList*& _s_out)
{
  return _a >>= (const Tango::DevCmdHistoryList*&) _s_out;
}

CORBA::Boolean operator >>= (const CORBA::Any& _a, const Tango::DevCmdHistoryList*& _s_out)
{
  _s_out = 0;
  Tango::DevCmdHistoryList* stmp = (Tango::DevCmdHistoryList*) _a.PR_getCachedData();
  if( stmp == 0 ) {
    tcDescriptor tcdesc;
    stmp = new Tango::DevCmdHistoryList;
    _0RL_buildDesc_s0_cTango_mDevCmdHistory(tcdesc, *stmp);
    if( _a.PR_unpackTo(Tango::_tc_DevCmdHistoryList, &tcdesc)) {
      ((CORBA::Any*)&_a)->PR_setCachedData((void*)stmp, _0RL_seq_delete_Tango_mDevCmdHistoryList);
      _s_out = stmp;
      return 1;
    } else {
      delete (Tango::DevCmdHistoryList *)stmp;
      return 0;
    }
  } else {
    CORBA::TypeCode_var tctmp = _a.type();
    if( tctmp->equivalent(Tango::_tc_DevCmdHistoryList) ) {
      _s_out = stmp;
      return 1;
    } else {
      return 0;
    }
  }
}

void _0RL_delete_Tango_mDevAttrHistory(void* _data) {
  Tango::DevAttrHistory* _0RL_t = (Tango::DevAttrHistory*) _data;
  delete _0RL_t;
}

static CORBA::Boolean
_0RL_tcParser_getMemberDesc_Tango_mDevAttrHistory(const tcStructDesc *_desc, CORBA::ULong _index, tcDescriptor &_newdesc){
  switch (_index) {
  case 0:
    _0RL_buildDesc_cboolean(_newdesc, ((Tango::DevAttrHistory*)_desc->opq_struct)->attr_failed);
    return 1;
  case 1:
    _0RL_buildDesc_cTango_mAttributeValue(_newdesc, ((Tango::DevAttrHistory*)_desc->opq_struct)->value);
    return 1;
  case 2:
    _0RL_buildDesc_s0_cTango_mDevError(_newdesc, ((Tango::DevAttrHistory*)_desc->opq_struct)->errors);
    return 1;

  default:
    return 0;
  };
}
static CORBA::ULong

_0RL_tcParser_getMemberCount_Tango_mDevAttrHistory(const tcStructDesc *_desc)
{
  return 3;
}

void _0RL_buildDesc_cTango_mDevAttrHistory(tcDescriptor &_desc, const Tango::DevAttrHistory& _data)
{
  _desc.p_struct.getMemberDesc = _0RL_tcParser_getMemberDesc_Tango_mDevAttrHistory;
  _desc.p_struct.getMemberCount = _0RL_tcParser_getMemberCount_Tango_mDevAttrHistory;
  _desc.p_struct.opq_struct = (void *)&_data;
}



void operator<<=(CORBA::Any& _a, const Tango::DevAttrHistory& _s) {
  tcDescriptor _0RL_tcdesc;
  _0RL_buildDesc_cTango_mDevAttrHistory(_0RL_tcdesc, _s);
  _a.PR_packFrom(_0RL_tc_Tango_mDevAttrHistory, &_0RL_tcdesc);
}
 
void operator<<=(CORBA::Any& _a, Tango::DevAttrHistory* _sp) {
  tcDescriptor _0RL_tcdesc;
  _0RL_buildDesc_cTango_mDevAttrHistory(_0RL_tcdesc, *_sp);
  _a.PR_packFrom(_0RL_tc_Tango_mDevAttrHistory, &_0RL_tcdesc);
  delete _sp;
}

CORBA::Boolean operator>>=(const CORBA::Any& _a, Tango::DevAttrHistory*& _sp) {
  return _a >>= (const Tango::DevAttrHistory*&) _sp;
}

CORBA::Boolean operator>>=(const CORBA::Any& _a, const Tango::DevAttrHistory*& _sp) {
  _sp = (Tango::DevAttrHistory *) _a.PR_getCachedData();
  if (_sp == 0) {
    tcDescriptor _0RL_tcdesc;
    _sp = new Tango::DevAttrHistory;
    _0RL_buildDesc_cTango_mDevAttrHistory(_0RL_tcdesc, *_sp);
    if (_a.PR_unpackTo(_0RL_tc_Tango_mDevAttrHistory, &_0RL_tcdesc)) {
      ((CORBA::Any *)&_a)->PR_setCachedData((void*)_sp, _0RL_delete_Tango_mDevAttrHistory);
      return 1;
    } else {
      delete (Tango::DevAttrHistory *)_sp; _sp = 0;
      return 0;
    }
  } else {
    CORBA::TypeCode_var _0RL_tctmp = _a.type();
    if (_0RL_tctmp->equivalent(_0RL_tc_Tango_mDevAttrHistory)) return 1;
    _sp = 0;
    return 0;
  }
}
#ifndef __0RL_tcParser_buildDesc_s0_cTango_mDevAttrHistory__
#define __0RL_tcParser_buildDesc_s0_cTango_mDevAttrHistory__
static void
_0RL_tcParser_setElementCount_s0_cTango_mDevAttrHistory(const tcSequenceDesc* _desc, CORBA::ULong _len)
{
  ((_CORBA_Unbounded_Sequence< Tango::DevAttrHistory > *)_desc->opq_seq)->length(_len);
}

static CORBA::ULong
_0RL_tcParser_getElementCount_s0_cTango_mDevAttrHistory(const tcSequenceDesc* _desc)
{
  return ((_CORBA_Unbounded_Sequence< Tango::DevAttrHistory > *)_desc->opq_seq)->length();
}

static CORBA::Boolean
_0RL_tcParser_getElementDesc_s0_cTango_mDevAttrHistory(const tcSequenceDesc* _desc, CORBA::ULong _index, tcDescriptor& _newdesc, _CORBA_ULong& _contiguous)
{
  _0RL_buildDesc_cTango_mDevAttrHistory(_newdesc, (*((_CORBA_Unbounded_Sequence< Tango::DevAttrHistory > *)_desc->opq_seq))[_index]);


  return 1;
}

static void
_0RL_buildDesc_s0_cTango_mDevAttrHistory(tcDescriptor &_desc, const _CORBA_Unbounded_Sequence< Tango::DevAttrHistory > & _data)
{
  _desc.p_sequence.opq_seq = (void*) &_data;
  _desc.p_sequence.setElementCount =
    _0RL_tcParser_setElementCount_s0_cTango_mDevAttrHistory;
  _desc.p_sequence.getElementCount =
    _0RL_tcParser_getElementCount_s0_cTango_mDevAttrHistory;
  _desc.p_sequence.getElementDesc =
    _0RL_tcParser_getElementDesc_s0_cTango_mDevAttrHistory;
  }
#endif

void operator <<= (CORBA::Any& _a, const Tango::DevAttrHistoryList& _s)
{
  tcDescriptor tcdesc;
  _0RL_buildDesc_s0_cTango_mDevAttrHistory(tcdesc, _s);
  _a.PR_packFrom(Tango::_tc_DevAttrHistoryList, &tcdesc);
}

void _0RL_seq_delete_Tango_mDevAttrHistoryList(void* _data)
{
  delete (Tango::DevAttrHistoryList*)_data;
}

CORBA::Boolean operator >>= (const CORBA::Any& _a, Tango::DevAttrHistoryList*& _s_out)
{
  return _a >>= (const Tango::DevAttrHistoryList*&) _s_out;
}

CORBA::Boolean operator >>= (const CORBA::Any& _a, const Tango::DevAttrHistoryList*& _s_out)
{
  _s_out = 0;
  Tango::DevAttrHistoryList* stmp = (Tango::DevAttrHistoryList*) _a.PR_getCachedData();
  if( stmp == 0 ) {
    tcDescriptor tcdesc;
    stmp = new Tango::DevAttrHistoryList;
    _0RL_buildDesc_s0_cTango_mDevAttrHistory(tcdesc, *stmp);
    if( _a.PR_unpackTo(Tango::_tc_DevAttrHistoryList, &tcdesc)) {
      ((CORBA::Any*)&_a)->PR_setCachedData((void*)stmp, _0RL_seq_delete_Tango_mDevAttrHistoryList);
      _s_out = stmp;
      return 1;
    } else {
      delete (Tango::DevAttrHistoryList *)stmp;
      return 0;
    }
  } else {
    CORBA::TypeCode_var tctmp = _a.type();
    if( tctmp->equivalent(Tango::_tc_DevAttrHistoryList) ) {
      _s_out = stmp;
      return 1;
    } else {
      return 0;
    }
  }
}

static void
_0RL_tcParser_setObjectPtr_Tango_mDevice(const tcObjrefDesc *_desc, CORBA::Object_ptr _ptr)
{
  Tango::Device_ptr _p = Tango::Device::_narrow(_ptr);
  Tango::Device_ptr* pp = (Tango::Device_ptr*)_desc->opq_objref;
  if (_desc->opq_release && !CORBA::is_nil(*pp)) CORBA::release(*pp);
  *pp = _p;
  CORBA::release(_ptr);
}

static CORBA::Object_ptr
_0RL_tcParser_getObjectPtr_Tango_mDevice(const tcObjrefDesc *_desc)
{
  return (CORBA::Object_ptr) *((Tango::Device_ptr*)_desc->opq_objref);
}

void _0RL_buildDesc_cTango_mDevice(tcDescriptor& _desc, const _CORBA_ObjRef_tcDesc_arg< Tango::_objref_Device, Tango::Device_Helper> & _d)
{
  _desc.p_objref.opq_objref = (void*) &_d._data;
  _desc.p_objref.opq_release = _d._rel;
  _desc.p_objref.setObjectPtr = _0RL_tcParser_setObjectPtr_Tango_mDevice;
  _desc.p_objref.getObjectPtr = _0RL_tcParser_getObjectPtr_Tango_mDevice;
}

void _0RL_delete_Tango_mDevice(void* _data) {
  CORBA::release((Tango::Device_ptr) _data);
}

void operator<<=(CORBA::Any& _a, Tango::Device_ptr _s) {
  tcDescriptor tcd;
  _CORBA_ObjRef_tcDesc_arg< Tango::_objref_Device, Tango::Device_Helper>  tmp(_s,0);
  _0RL_buildDesc_cTango_mDevice(tcd, tmp);
  _a.PR_packFrom(Tango::_tc_Device, &tcd);
}

void operator<<=(CORBA::Any& _a, Tango::Device_ptr* _sp) {
  _a <<= *_sp;
  CORBA::release(*_sp);
  *_sp = Tango::Device::_nil();
}

CORBA::Boolean operator>>=(const CORBA::Any& _a, Tango::Device_ptr& _s) {
  Tango::Device_ptr sp = (Tango::Device_ptr) _a.PR_getCachedData();
  if (sp == 0) {
    tcDescriptor tcd;
    Tango::Device_var tmp;
    _0RL_buildDesc_cTango_mDevice(tcd, tmp);
    if( _a.PR_unpackTo(Tango::_tc_Device, &tcd) ) {
      if (!omniORB::omniORB_27_CompatibleAnyExtraction) {
        ((CORBA::Any*)&_a)->PR_setCachedData((void*)(Tango::Device_ptr)tmp,_0RL_delete_Tango_mDevice);
      }
      _s = tmp._retn();
      return 1;
    } else {
      _s = Tango::Device::_nil(); return 0;
    }
  }
  else {
    CORBA::TypeCode_var tc = _a.type();
    if (tc->equivalent(Tango::_tc_Device)) {
    _s = sp; return 1;
    }
    else {
    _s = Tango::Device::_nil(); return 0;
    }
  }
}

static void
_0RL_tcParser_setObjectPtr_Tango_mDevice__2(const tcObjrefDesc *_desc, CORBA::Object_ptr _ptr)
{
  Tango::Device_2_ptr _p = Tango::Device_2::_narrow(_ptr);
  Tango::Device_2_ptr* pp = (Tango::Device_2_ptr*)_desc->opq_objref;
  if (_desc->opq_release && !CORBA::is_nil(*pp)) CORBA::release(*pp);
  *pp = _p;
  CORBA::release(_ptr);
}

static CORBA::Object_ptr
_0RL_tcParser_getObjectPtr_Tango_mDevice__2(const tcObjrefDesc *_desc)
{
  return (CORBA::Object_ptr) *((Tango::Device_2_ptr*)_desc->opq_objref);
}

void _0RL_buildDesc_cTango_mDevice__2(tcDescriptor& _desc, const _CORBA_ObjRef_tcDesc_arg< Tango::_objref_Device_2, Tango::Device_2_Helper> & _d)
{
  _desc.p_objref.opq_objref = (void*) &_d._data;
  _desc.p_objref.opq_release = _d._rel;
  _desc.p_objref.setObjectPtr = _0RL_tcParser_setObjectPtr_Tango_mDevice__2;
  _desc.p_objref.getObjectPtr = _0RL_tcParser_getObjectPtr_Tango_mDevice__2;
}

void _0RL_delete_Tango_mDevice__2(void* _data) {
  CORBA::release((Tango::Device_2_ptr) _data);
}

void operator<<=(CORBA::Any& _a, Tango::Device_2_ptr _s) {
  tcDescriptor tcd;
  _CORBA_ObjRef_tcDesc_arg< Tango::_objref_Device_2, Tango::Device_2_Helper>  tmp(_s,0);
  _0RL_buildDesc_cTango_mDevice__2(tcd, tmp);
  _a.PR_packFrom(Tango::_tc_Device_2, &tcd);
}

void operator<<=(CORBA::Any& _a, Tango::Device_2_ptr* _sp) {
  _a <<= *_sp;
  CORBA::release(*_sp);
  *_sp = Tango::Device_2::_nil();
}

CORBA::Boolean operator>>=(const CORBA::Any& _a, Tango::Device_2_ptr& _s) {
  Tango::Device_2_ptr sp = (Tango::Device_2_ptr) _a.PR_getCachedData();
  if (sp == 0) {
    tcDescriptor tcd;
    Tango::Device_2_var tmp;
    _0RL_buildDesc_cTango_mDevice__2(tcd, tmp);
    if( _a.PR_unpackTo(Tango::_tc_Device_2, &tcd) ) {
      if (!omniORB::omniORB_27_CompatibleAnyExtraction) {
        ((CORBA::Any*)&_a)->PR_setCachedData((void*)(Tango::Device_2_ptr)tmp,_0RL_delete_Tango_mDevice__2);
      }
      _s = tmp._retn();
      return 1;
    } else {
      _s = Tango::Device_2::_nil(); return 0;
    }
  }
  else {
    CORBA::TypeCode_var tc = _a.type();
    if (tc->equivalent(Tango::_tc_Device_2)) {
    _s = sp; return 1;
    }
    else {
    _s = Tango::Device_2::_nil(); return 0;
    }
  }
}

